===== src/features/gpx-tools/hooks/useGpxLoader.js =====
import { useState, useEffect, useCallback } from 'react'
import L from 'leaflet'
import 'leaflet-gpx'

const useGpxLoader = gpxUrl => {
	const [points, setPoints] = useState([])
	const [loading, setLoading] = useState(false)
	const [error, setError] = useState(null)
	const [stats, setStats] = useState(null)

	const loadGpx = useCallback(async url => {
		if (!url) {
			setPoints([])
			setStats(null)
			return
		}

		setLoading(true)
		setError(null)

		try {
			// –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ GPX
			const gpx = new L.GPX(url, {
				async: true,
				max_point_interval: 10000,
				parseElements: ['track', 'route', 'waypoint'],
			})

			// –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ GPX
			await new Promise((resolve, reject) => {
				gpx.on('loaded', function (e) {
					const track = e.target
					const pointsArray = []

					// –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ —Ç–æ—á–∫–∏ –∏–∑ —Ç—Ä–µ–∫–∞
					track.getLayers().forEach(layer => {
						if (layer instanceof L.Polyline) {
							const latlngs = layer.getLatLngs()
							latlngs.forEach((latlng, index) => {
								const point = {
									lat: latlng.lat,
									lng: latlng.lng,
									elevation: latlng.meta?.ele,
									time: latlng.meta?.time,
									timestamp: latlng.meta?.time
										? new Date(latlng.meta.time).getTime()
										: null,
								}
								pointsArray.push(point)
							})
						}
					})

					setPoints(pointsArray)

					// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π GPX
					// –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–µ—Ç–æ–¥
					const extensionData = track.get_duration_string
						? track.get_duration_string()
						: null

					// –ü–æ–ª—É—á–∞–µ–º –±–∞–∑–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
					const totalDistance = track.get_distance ? track.get_distance() : 0
					const totalTime = track.get_total_time ? track.get_total_time() : 0
					const elevationGain = track.get_elevation_gain
						? track.get_elevation_gain()
						: 0
					const elevationLoss = track.get_elevation_loss
						? track.get_elevation_loss()
						: 0

					setStats({
						totalDistance: totalDistance || 0,
						totalTime: totalTime || 0,
						elevationGain: elevationGain || 0,
						elevationLoss: elevationLoss || 0,
						pointsCount: pointsArray.length,
						extensionData: extensionData || {},
					})

					resolve()
				})

				gpx.on('error', function (e) {
					reject(new Error(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ GPX: ${e.error}`))
				})
			})
		} catch (err) {
			console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ GPX:', err)
			setError(err.message)
			setPoints([])
			setStats(null)
		} finally {
			setLoading(false)
		}
	}, [])

	useEffect(() => {
		loadGpx(gpxUrl)
	}, [gpxUrl, loadGpx])

	return { points, loading, error, stats, reload: () => loadGpx(gpxUrl) }
}

export default useGpxLoader



===== src/features/gpx-tools/index.js =====
export { default as GpxToolsPage } from './ui/GpxToolsPage'



===== src/features/gpx-tools/utils/gpxCalculations.js =====
// –§—É–Ω–∫—Ü–∏–∏ —Ä–∞—Å—á–µ—Ç–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –∏ –¥—Ä—É–≥–∏—Ö –º–µ—Ç—Ä–∏–∫ –¥–ª—è GPX

/**
 * –†–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ (–º–µ—Ç—Ä—ã)
 */
export const calculateDistance = (lat1, lon1, lat2, lon2) => {
	const R = 6371000 // —Ä–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –º–µ—Ç—Ä–∞—Ö
	const dLat = ((lat2 - lat1) * Math.PI) / 180
	const dLon = ((lon2 - lon1) * Math.PI) / 180
	const a =
		Math.sin(dLat / 2) * Math.sin(dLat / 2) +
		Math.cos((lat1 * Math.PI) / 180) *
			Math.cos((lat2 * Math.PI) / 180) *
			Math.sin(dLon / 2) *
			Math.sin(dLon / 2)
	const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
	const distance = R * c

	// –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (–º–µ–Ω—å—à–µ 1–º - —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ —à—É–º)
	return distance < 1 ? 0 : distance
}

/**
 * –†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ (–∫–º/—á)
 */
export const calculateSpeed = (point1, point2) => {
	if (!point1 || !point2) return 0

	// –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
	const time1 =
		point1.timestamp || (point1.time ? new Date(point1.time).getTime() : null)
	const time2 =
		point2.timestamp || (point2.time ? new Date(point2.time).getTime() : null)

	if (!time1 || !time2 || time1 === time2) return 0

	// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
	const distance = calculateDistance(
		point1.lat,
		point1.lng,
		point2.lat,
		point2.lng
	)
	const timeDiff = (time2 - time1) / 1000 // —Å–µ–∫—É–Ω–¥—ã

	if (timeDiff <= 0) return 0

	// –°–∫–æ—Ä–æ—Å—Ç—å –≤ –∫–º/—á
	return (distance / timeDiff) * 3.6
}

/**
 * –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–∫–æ–≤ - –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–º—É –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ç–æ—á–µ–∫
 */
export const normalizeTracks = (track1Points, track2Points) => {
	const maxPoints = Math.max(track1Points.length, track2Points.length)

	if (track1Points.length === track2Points.length) {
		return { track1: track1Points, track2: track2Points }
	}

	// –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö —Ç–æ—á–µ–∫
	const normalizedTrack1 = interpolateTrack(track1Points, maxPoints)
	const normalizedTrack2 = interpolateTrack(track2Points, maxPoints)

	return { track1: normalizedTrack1, track2: normalizedTrack2 }
}

/**
 * –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è —Ç–æ—á–µ–∫ —Ç—Ä–µ–∫–∞
 */
const interpolateTrack = (points, targetCount) => {
	if (points.length >= targetCount || points.length < 2) {
		return points.slice(0, targetCount)
	}

	const result = []
	const step = (points.length - 1) / (targetCount - 1)

	for (let i = 0; i < targetCount; i++) {
		const index = i * step
		const prevIndex = Math.floor(index)
		const nextIndex = Math.min(Math.ceil(index), points.length - 1)

		if (prevIndex === nextIndex) {
			result.push(points[prevIndex])
		} else {
			const ratio = index - prevIndex
			const prevPoint = points[prevIndex]
			const nextPoint = points[nextIndex]

			// –õ–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
			const interpolatedPoint = {
				lat: prevPoint.lat + (nextPoint.lat - prevPoint.lat) * ratio,
				lng: prevPoint.lng + (nextPoint.lng - prevPoint.lng) * ratio,
				elevation:
					prevPoint.elevation && nextPoint.elevation
						? prevPoint.elevation +
						  (nextPoint.elevation - prevPoint.elevation) * ratio
						: undefined,
				timestamp:
					prevPoint.timestamp && nextPoint.timestamp
						? prevPoint.timestamp +
						  (nextPoint.timestamp - prevPoint.timestamp) * ratio
						: undefined,
				time: prevPoint.time, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º—è –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ç–æ—á–∫–∏
			}
			result.push(interpolatedPoint)
		}
	}

	return result
}

/**
 * –†–∞—Å—á–µ—Ç –æ—Ç—Å—Ç–∞–≤–∞–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —Ç—Ä–µ–∫–∞–º–∏ –≤ –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–µ
 */
export const calculateLag = (track1Points, track2Points) => {
	const { track1, track2 } = normalizeTracks(track1Points, track2Points)
	const lags = []

	for (let i = 0; i < track1.length; i++) {
		const point1 = track1[i]
		const point2 = track2[i]

		if (!point1 || !point2) {
			lags.push({ distance: 0, time: 0 })
			continue
		}

		// –û—Ç—Å—Ç–∞–≤–∞–Ω–∏–µ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é (–º–µ—Ç—Ä—ã)
		const distanceLag = calculateDistance(
			point1.lat,
			point1.lng,
			point2.lat,
			point2.lng
		)

		// –û—Ç—Å—Ç–∞–≤–∞–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å–µ–∫—É–Ω–¥—ã)
		let timeLag = 0
		if (point1.timestamp && point2.timestamp) {
			timeLag = Math.abs(point1.timestamp - point2.timestamp) / 1000
		}

		lags.push({
			distance: distanceLag,
			time: timeLag,
			pointIndex: i,
		})
	}

	return lags
}

/**
 * –ü–æ–∏—Å–∫ –∫–ª—é—á–µ–≤—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –æ—Ç—Å—Ç–∞–≤–∞–Ω–∏–µ–º
 */
export const findKeySegments = (lags, segmentSize = 10) => {
	const segments = []

	for (let i = 0; i <= lags.length - segmentSize; i++) {
		const segment = lags.slice(i, i + segmentSize)
		const avgDistance =
			segment.reduce((sum, lag) => sum + lag.distance, 0) / segmentSize
		const avgTime =
			segment.reduce((sum, lag) => sum + lag.time, 0) / segmentSize

		segments.push({
			startIndex: i,
			endIndex: i + segmentSize - 1,
			avgDistance,
			avgTime,
			totalDistance: segment.reduce((sum, lag) => sum + lag.distance, 0),
			totalTime: segment.reduce((sum, lag) => sum + lag.time, 0),
		})
	}

	// –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –æ—Ç—Å—Ç–∞–≤–∞–Ω–∏—é
	return segments.sort((a, b) => b.avgDistance - a.avgDistance).slice(0, 5)
}



===== src/features/gpx-tools/utils/gpxParser.js =====
/**
 * –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ GPX —Ñ–∞–π–ª–æ–≤
 */

/**
 * –ü–∞—Ä—Å–∏—Ç GPX —Ñ–∞–π–ª –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫
 */
export function parseGPX(gpxText) {
	const points = []

	try {
		const parser = new DOMParser()
		const xmlDoc = parser.parseFromString(gpxText, 'text/xml')

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
		const parserError = xmlDoc.getElementsByTagName('parsererror')
		if (parserError.length > 0) {
			console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ XML:', parserError[0].textContent)
			return points
		}

		// –ò—â–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ç–∏–ø—ã —Ç–æ—á–µ–∫
		const pointTypes = ['trkpt', 'rtept', 'wpt']

		pointTypes.forEach(type => {
			const elements = xmlDoc.getElementsByTagName(type)
			if (elements.length > 0) {
				console.log(`–ù–∞–π–¥–µ–Ω–æ <${type}> —ç–ª–µ–º–µ–Ω—Ç–æ–≤: ${elements.length}`)
			}
		})

		// –í –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å –∏—â–µ–º —Ç—Ä–µ–∫–ø–æ–∏–Ω—Ç—ã (trkpt)
		const trkpts = xmlDoc.getElementsByTagName('trkpt')

		if (trkpts.length > 0) {
			for (let i = 0; i < trkpts.length; i++) {
				const trkpt = trkpts[i]
				const point = parseTrackPoint(trkpt, i)
				if (point) {
					points.push(point)
				}
			}
		} else {
			// –ï—Å–ª–∏ –Ω–µ—Ç —Ç—Ä–µ–∫–ø–æ–∏–Ω—Ç–æ–≤, –∏—â–µ–º —Ç–æ—á–∫–∏ –º–∞—Ä—à—Ä—É—Ç–∞ (rtept)
			const rtepts = xmlDoc.getElementsByTagName('rtept')
			if (rtepts.length > 0) {
				for (let i = 0; i < rtepts.length; i++) {
					const rtept = rtepts[i]
					const point = parseRoutePoint(rtept, i)
					if (point) {
						points.push(point)
					}
				}
			}
		}
	} catch (error) {
		console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ GPX:', error)
	}

	return points
}

/**
 * –ü–∞—Ä—Å–∏—Ç —Ç—Ä–µ–∫–ø–æ–∏–Ω—Ç (trkpt)
 */
function parseTrackPoint(trkpt, index) {
	try {
		const lat = parseFloat(trkpt.getAttribute('lat'))
		const lon = parseFloat(trkpt.getAttribute('lon'))

		if (isNaN(lat) || isNaN(lon)) {
			return null
		}

		const eleElem = trkpt.getElementsByTagName('ele')[0]
		const timeElem = trkpt.getElementsByTagName('time')[0]
		const nameElem = trkpt.getElementsByTagName('name')[0]
		const descElem = trkpt.getElementsByTagName('desc')[0]

		return {
			lat: lat,
			lng: lon,
			index: index,
			type: 'track',
			elevation: eleElem ? parseFloat(eleElem.textContent) : null,
			time: timeElem ? timeElem.textContent : null,
			name: nameElem ? nameElem.textContent : null,
			description: descElem ? descElem.textContent : null,
			timestamp: timeElem ? new Date(timeElem.textContent).getTime() : null,
		}
	} catch (error) {
		console.warn('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ç—Ä–µ–∫–ø–æ–∏–Ω—Ç–∞:', error)
		return null
	}
}

/**
 * –ü–∞—Ä—Å–∏—Ç —Ç–æ—á–∫—É –º–∞—Ä—à—Ä—É—Ç–∞ (rtept)
 */
function parseRoutePoint(rtept, index) {
	try {
		const lat = parseFloat(rtept.getAttribute('lat'))
		const lon = parseFloat(rtept.getAttribute('lon'))

		if (isNaN(lat) || isNaN(lon)) {
			return null
		}

		const nameElem = rtept.getElementsByTagName('name')[0]
		const descElem = rtept.getElementsByTagName('desc')[0]

		return {
			lat: lat,
			lng: lon,
			index: index,
			type: 'route',
			name: nameElem ? nameElem.textContent : null,
			description: descElem ? descElem.textContent : null,
		}
	} catch (error) {
		console.warn('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ç–æ—á–∫–∏ –º–∞—Ä—à—Ä—É—Ç–∞:', error)
		return null
	}
}

/**
 * –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–æ—á–∫–∏ –∏–∑ GPX —Å–ª–æ—è Leaflet
 */
export function getGPXPoints(track) {
	const points = []

	if (!track || !track._layers) {
		return points
	}

	Object.values(track._layers).forEach(layer => {
		if (layer instanceof L.Polyline) {
			try {
				const latLngs = layer.getLatLngs()
				extractLatLngs(latLngs, points)
			} catch (error) {
				console.warn('–û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–æ—á–µ–∫ –∏–∑ —Å–ª–æ—è:', error)
			}
		}
	})

	return points
}

/**
 * –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ Leaflet latLngs
 */
function extractLatLngs(latLngs, points) {
	if (!Array.isArray(latLngs)) {
		return
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
	if (latLngs.length > 0) {
		const firstElement = latLngs[0]

		// –ï—Å–ª–∏ —ç—Ç–æ –ø–ª–æ—Å–∫–∏–π –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫ L.LatLng
		if (firstElement.lat !== undefined) {
			latLngs.forEach((ll, index) => {
				points.push({
					lat: ll.lat,
					lng: ll.lng,
					index: points.length,
				})
			})
		}
		// –ï—Å–ª–∏ —ç—Ç–æ –≤–ª–æ–∂–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ (—Å–µ–≥–º–µ–Ω—Ç—ã)
		else if (Array.isArray(firstElement)) {
			latLngs.forEach(segment => {
				if (Array.isArray(segment)) {
					segment.forEach(ll => {
						if (ll && ll.lat !== undefined) {
							points.push({
								lat: ll.lat,
								lng: ll.lng,
								index: points.length,
							})
						}
					})
				}
			})
		}
	}
}

export default {
	parseGPX,
	getGPXPoints,
}



===== src/features/gpx-tools/ui/GpxComparator.jsx =====
import React, { useState, useEffect, useRef } from 'react'
import L from 'leaflet' // ‚Üê –î–û–ë–ê–í–¨–¢–ï –ò–ú–ü–û–†–¢ L
import 'leaflet/dist/leaflet.css' // ‚Üê –î–û–ë–ê–í–¨–¢–ï
import 'leaflet-gpx' // ‚Üê –î–û–ë–ê–í–¨–¢–ï
import {
	Card,
	Alert,
	Typography,
	Row,
	Col,
	Statistic,
	Button,
	Tabs,
	Spin,
	Empty,
} from 'antd'
import {
	PlayCircleOutlined,
	PauseCircleOutlined,
	BarChartOutlined,
	AreaChartOutlined,
	LineChartOutlined,
} from '@ant-design/icons'
import styles from './GpxComparator.module.css'
import { calculateLag, findKeySegments } from '../utils/gpxCalculations'
import useGpxLoader from '../hooks/useGpxLoader'

const { Text } = Typography
const { TabPane } = Tabs

export default function GpxComparator({ tracks = [], user }) {
	// üî• –í–°–ï –•–£–ö–ò –î–û–õ–ñ–ù–´ –ë–´–¢–¨ –ó–î–ï–°–¨, –í–ù–£–¢–†–ò –ö–û–ú–ü–û–ù–ï–ù–¢–ê üî•

	// useRef —Ö—É–∫–∏
	const playerIntervalRef = useRef(null)
	const mapRef = useRef(null)
	const mapInstanceRef = useRef(null)
	const gpx1Ref = useRef(null)
	const gpx2Ref = useRef(null)

	// useState —Ö—É–∫–∏
	const [isPlaying, setIsPlaying] = useState(false)
	const [currentPointIndex, setCurrentPointIndex] = useState(0)
	const [lags, setLags] = useState([])
	const [keySegments, setKeySegments] = useState([])

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã (useEffect –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–Ω—É—Ç—Ä–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞)
	useEffect(() => {
		if (!mapRef.current || mapInstanceRef.current) return

		console.log('üó∫Ô∏è –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –∫–∞—Ä—Ç—É –≤ GpxComparator')

		const map = L.map(mapRef.current).setView([52.416925, 103.738906], 15)

		L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
			attribution: '¬© OpenStreetMap',
			maxZoom: 19,
		}).addTo(map)

		mapInstanceRef.current = map

		return () => {
			if (mapInstanceRef.current) {
				mapInstanceRef.current.remove()
				mapInstanceRef.current = null
			}
		}
	}, [])

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ 2 —Ç—Ä–µ–∫–∞
	if (tracks.length !== 2) {
		return (
			<Card className={styles.container}>
				<Alert
					message='–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å 2 —Ç—Ä–µ–∫–∞ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è'
					description="–í–µ—Ä–Ω–∏—Ç–µ—Å—å –Ω–∞ –≤–∫–ª–∞–¥–∫—É '–ú–æ–∏ —Ç—Ä–µ–∫–∏' –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥–≤–∞ —Ç—Ä–µ–∫–∞"
					type='warning'
					showIcon
				/>
			</Card>
		)
	}

	// –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–≤—ã–π –∏ –≤—Ç–æ—Ä–æ–π —Ç—Ä–µ–∫–∏
	const track1 = tracks[0]
	const track2 = tracks[1]

	// === –û–¢–õ–ê–î–ö–ê ===
	console.log('=== GpxComparator Debug ===')
	console.log('Tracks array:', tracks)
	console.log('Track 1 object:', track1)
	console.log('Track 2 object:', track2)
	console.log('Track 1 filename:', track1?.filename)
	console.log('Track 2 filename:', track2?.filename)
	console.log('Track 1 URL from prop:', track1?.url)
	console.log('Track 2 URL from prop:', track2?.url)
	// === –ö–û–ù–ï–¶ –û–¢–õ–ê–î–ö–ò ===

	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è URL —Ç—Ä–µ–∫–∞
	const getTrackUrl = track => {
		if (!track || !track.filename) return null
		return `https://xsqelqxwthjufdwfdecf.supabase.co/storage/v1/object/public/gpx-tracks/${track.filename}`
	}

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—É–∫ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ—á–µ–∫
	const {
		points: track1Points,
		loading: loading1,
		error: error1,
		stats: stats1,
	} = useGpxLoader(getTrackUrl(track1))

	const {
		points: track2Points,
		loading: loading2,
		error: error2,
		stats: stats2,
	} = useGpxLoader(getTrackUrl(track2))

	const loading = loading1 || loading2

	// –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–æ–≤ –Ω–∞ –∫–∞—Ä—Ç—É (—ç—Ç–æ—Ç useEffect —Ç–æ–∂–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–Ω—É—Ç—Ä–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞)
	useEffect(() => {
		if (!mapInstanceRef.current || !track1 || !track2) return

		console.log('üì• –ó–∞–≥—Ä—É–∂–∞—é —Ç—Ä–µ–∫–∏ –Ω–∞ –∫–∞—Ä—Ç—É:', track1.url, track2.url)

		// –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Å–ª–æ–µ–≤
		if (gpx1Ref.current) mapInstanceRef.current.removeLayer(gpx1Ref.current)
		if (gpx2Ref.current) mapInstanceRef.current.removeLayer(gpx2Ref.current)

		// –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ 1
		gpx1Ref.current = new L.GPX(track1.url, {
			async: true,
			polyline_options: { color: '#1890ff', weight: 3, opacity: 0.8 },
			marker_options: null,
		})

		gpx1Ref.current.on('loaded', e => {
			console.log('‚úÖ –¢—Ä–µ–∫ 1 –∑–∞–≥—Ä—É–∂–µ–Ω')
		})

		gpx1Ref.current.on('error', e => {
			console.error('‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–µ–∫–∞ 1:', e.error)
		})

		gpx1Ref.current.addTo(mapInstanceRef.current)

		// –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ 2
		gpx2Ref.current = new L.GPX(track2.url, {
			async: true,
			polyline_options: { color: '#f5222d', weight: 3, opacity: 0.8 },
			marker_options: null,
		})

		gpx2Ref.current.on('loaded', e => {
			console.log('‚úÖ –¢—Ä–µ–∫ 2 –∑–∞–≥—Ä—É–∂–µ–Ω')
			// –ö–æ–≥–¥–∞ –æ–±–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã, —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É
			if (gpx1Ref.current) {
				const bounds1 = gpx1Ref.current.getBounds()
				const bounds2 = e.target.getBounds()
				const bounds = bounds1.extend(bounds2)
				mapInstanceRef.current.fitBounds(bounds.pad(0.1))
			}
		})

		gpx2Ref.current.on('error', e => {
			console.error('‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–µ–∫–∞ 2:', e.error)
		})

		gpx2Ref.current.addTo(mapInstanceRef.current)
	}, [track1, track2])

	// –†–∞—Å—á–µ—Ç –æ—Ç—Å—Ç–∞–≤–∞–Ω–∏—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ç—Ä–µ–∫–æ–≤
	useEffect(() => {
		if (track1Points.length > 0 && track2Points.length > 0) {
			const calculatedLags = calculateLag(track1Points, track2Points)
			setLags(calculatedLags)

			const segments = findKeySegments(calculatedLags)
			setKeySegments(segments)
		}
	}, [track1Points, track2Points])

	// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º
	const handlePlayPause = () => {
		if (isPlaying) {
			// –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
			setIsPlaying(false)
			if (playerIntervalRef.current) {
				clearInterval(playerIntervalRef.current)
				playerIntervalRef.current = null
			}
		} else {
			// –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
			setIsPlaying(true)
			const maxPoints = Math.min(track1Points.length, track2Points.length)

			playerIntervalRef.current = setInterval(() => {
				setCurrentPointIndex(prev => {
					const next = prev + 1
					if (next >= maxPoints) {
						// –î–æ—Å—Ç–∏–≥–ª–∏ –∫–æ–Ω—Ü–∞ - –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º
						setIsPlaying(false)
						if (playerIntervalRef.current) {
							clearInterval(playerIntervalRef.current)
							playerIntervalRef.current = null
						}
						return prev
					}
					return next
				})
			}, 100) // 10 —Ç–æ—á–µ–∫ –≤ —Å–µ–∫—É–Ω–¥—É
		}
	}

	// –û—á–∏—Å—Ç–∫–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
	useEffect(() => {
		return () => {
			if (playerIntervalRef.current) {
				clearInterval(playerIntervalRef.current)
			}
		}
	}, [])

	// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
	const getComparisonStats = () => {
		if (lags.length === 0) return null

		const maxDistanceLag = Math.max(...lags.map(lag => lag.distance))
		const maxTimeLag = Math.max(...lags.map(lag => lag.time))
		const avgDistanceLag =
			lags.reduce((sum, lag) => sum + lag.distance, 0) / lags.length
		const avgTimeLag =
			lags.reduce((sum, lag) => sum + lag.time, 0) / lags.length

		return {
			maxDistanceLag: maxDistanceLag.toFixed(1),
			maxTimeLag: maxTimeLag.toFixed(1),
			avgDistanceLag: avgDistanceLag.toFixed(1),
			avgTimeLag: avgTimeLag.toFixed(1),
		}
	}

	const stats = getComparisonStats()

	return (
		<Card className={styles.container}>
			{/* –ö–∞—Ä—Ç–∞ */}
			<div className={styles.mapSection}>
				<Card size='small' title='–ö–∞—Ä—Ç–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è'>
					<div
						ref={mapRef}
						style={{
							width: '100%',
							height: '400px',
							borderRadius: '8px',
							overflow: 'hidden',
							border: '1px solid #f0f0f0',
						}}
					/>
					<div
						style={{
							padding: '8px',
							background: '#fafafa',
							borderTop: '1px solid #f0f0f0',
							fontSize: '12px',
							color: '#666',
						}}
					>
						–°–∏–Ω–∏–π: {track1?.filename} ‚Ä¢ –ö—Ä–∞—Å–Ω—ã–π: {track2?.filename}
					</div>
				</Card>
			</div>

			{/* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç—Ä–µ–∫–∞—Ö */}
			<div className={styles.trackInfoHeader}>
				<Row gutter={[16, 16]}>
					<Col span={12}>
						<Card size='small'>
							<Text strong>–¢—Ä–µ–∫ 1</Text>
							<div className={styles.trackName}>{track1?.filename}</div>
							<Text type='secondary'>
								{track1?.time
									? `${Math.floor(track1.time / 60)}:${(track1.time % 60)
											.toString()
											.padStart(2, '0')}`
									: ''}
							</Text>
						</Card>
					</Col>
					<Col span={12}>
						<Card size='small'>
							<Text strong>–¢—Ä–µ–∫ 2</Text>
							<div className={styles.trackName}>{track2?.filename}</div>
							<Text type='secondary'>
								{track2?.time
									? `${Math.floor(track2.time / 60)}:${(track2.time % 60)
											.toString()
											.padStart(2, '0')}`
									: ''}
							</Text>
						</Card>
					</Col>
				</Row>
			</div>

			{/* –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –æ—Å—Ç–∞–µ—Ç—Å—è... */}
		</Card>
	)
}



===== src/features/gpx-tools/ui/GpxEditor.jsx =====
import React, { useState, useEffect, useRef, useCallback } from 'react'
import {
	Alert,
	Typography,
	Slider,
	Button,
	Space,
	Row,
	Col,
	Statistic,
	message,
	Spin,
	Card,
} from 'antd'
import { ScissorOutlined, SaveOutlined, UndoOutlined } from '@ant-design/icons'
import TrackVisualizer from './components/TrackVisualizer'
import styles from './GpxEditor.module.css'
import SaveTrackModal from './components/SaveTrackModal'
import supabase from '../../../supabase'
import TrackPlayer from './components/TrackPlayer'
import UnifiedMap from './components/UnifiedMap'


const { Text } = Typography

export default function GpxEditor({ track, onTrackUpdated, user }) {
	const [loading, setLoading] = useState(false)
	const [trackPoints, setTrackPoints] = useState([])
	const [trimStart, setTrimStart] = useState(0)
	const [trimEnd, setTrimEnd] = useState(0)
	const [trimmedStats, setTrimmedStats] = useState(null)
	const [hasLoaded, setHasLoaded] = useState(false)
	const [saveModalVisible, setSaveModalVisible] = useState(false)
	const [saving, setSaving] = useState(false)
	const [mapInstance, setMapInstance] = useState(null)

	useEffect(() => {
		if (!track) {
			setLoading(false)
			setHasLoaded(false)
			setMapInstance(null)
			return
		}

		setTrackPoints([])
		setTrimmedStats(null)
		setTrimStart(0)
		setTrimEnd(0)
		setHasLoaded(false)
	}, [track])

	const handleSaveTrack = async saveData => {
		console.log('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞ —Å –¥–∞–Ω–Ω—ã–º–∏:', saveData)

		if (!track || !trackPoints.length || !user || !trimmedStats) {
			message.warning('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è')
			return
		}

		try {
			setSaving(true)

			// 1. –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–µ–∑–∞–Ω–Ω—ã–µ —Ç–æ—á–∫–∏
			const trimmedPoints = trackPoints.slice(trimStart, trimEnd + 1)

			// 2. –°–æ–∑–¥–∞–µ–º GPX —Ñ–∞–π–ª
			const gpxContent = createGPXFromPoints(
				trimmedPoints,
				track,
				saveData.description
			)

			// 3. –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞
			let filename = saveData.filename || ''

			// –ï—Å–ª–∏ –∏–º—è –ø—É—Å—Ç–æ–µ - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
			if (!filename || filename.trim() === '') {
				const baseName = track.filename || 'track'
				const nameWithoutExt = baseName.replace(/\.gpx$/i, '')
				filename = `${nameWithoutExt}_edited_${Date.now()}.gpx`
			}

			// –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –µ—Å—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ .gpx
			if (!filename.toLowerCase().endsWith('.gpx')) {
				filename = filename + '.gpx'
			}

			// –î–ª—è –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è
			if (saveData.saveOption === 'overwrite') {
				filename = track.filename || filename
			}

			const filePath = `${Date.now()}_${user.id}_${filename}`

			console.log('–°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª:', {
				filePath,
				filename,
				saveOption: saveData.saveOption,
			})

			// 4. –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª –≤ Supabase Storage
			const { data: uploadData, error: uploadError } = await supabase.storage
				.from('gpx-tracks')
				.upload(filePath, gpxContent, {
					contentType: 'application/gpx+xml',
				})

			if (uploadError) throw uploadError

			// 5. –ü–æ–ª—É—á–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–π URL
			const { data: urlData } = supabase.storage
				.from('gpx-tracks')
				.getPublicUrl(filePath)

			const newTimeSeconds = Math.floor(trimmedStats.duration)

			// 6. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
			if (saveData.saveOption === 'overwrite') {
				// –ü–µ—Ä–µ–∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ç—Ä–µ–∫–∞
				const { error: updateError } = await supabase
					.from('lap_times')
					.update({
						time_seconds: newTimeSeconds,
						gpx_track_url: urlData.publicUrl,
						updated_at: new Date().toISOString(),
						comment: saveData.description || track.comment || '',
					})
					.eq('id', track.id)

				if (updateError) throw updateError
				message.success('–¢—Ä–µ–∫ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!')
			} else {
				// –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç—Ä–µ–∫–∞ - –ë–ï–ó –ü–û–õ–Ø filename
				const insertData = {
					user_id: user.id,
					time_seconds: newTimeSeconds,
					gpx_track_url: urlData.publicUrl,
					date: new Date().toISOString(),
					comment: saveData.description || '',
				}

				// –î–æ–±–∞–≤–ª—è–µ–º ski_model —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
				if (track.skiModel) {
					insertData.ski_model = track.skiModel
				}

				// –í—Å—Ç–∞–≤–ª—è–µ–º –≤ –±–∞–∑—É
				const { error: insertError } = await supabase
					.from('lap_times')
					.insert(insertData)

				if (insertError) throw insertError
				message.success('–ù–æ–≤—ã–π —Ç—Ä–µ–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω!')
			}

			setSaveModalVisible(false)
			onTrackUpdated?.()
		} catch (error) {
			console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', error)
			message.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç—Ä–µ–∫–∞: ${error.message}`)
		} finally {
			setSaving(false)
		}
	}

	const createGPXFromPoints = (points, originalTrack, description = '') => {
		const now = new Date().toISOString()

		let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx creator="Ski Leaderboard" version="1.0" xmlns="http://www.topografix.com/GPX/1/0">
	<metadata>
		<time>${now}</time>
		<name>${originalTrack.name || 'Edited Track'}</name>
		${description ? `<desc>${description}</desc>` : ''}
	</metadata>
	<trk>
		<name>${originalTrack.name || 'Edited Track'}</name>
		${description ? `<desc>${description}</desc>` : ''}
		<trkseg>`

		points.forEach((point, index) => {
			gpx += `
			<trkpt lat="${point.lat.toFixed(6)}" lon="${point.lng.toFixed(6)}">
				${point.elevation ? `<ele>${point.elevation.toFixed(1)}</ele>` : ''}
				${point.time ? `<time>${point.time}</time>` : ''}
			</trkpt>`
		})

		gpx += `
		</trkseg>
	</trk>
</gpx>`

		return gpx
	}

	const handleTrackLoaded = useCallback(
		(track, stats, points, gpxData) => {
			if (hasLoaded) return

			const extensionTime = gpxData?.totalTime
			const hasTimestamps = points.some(p => p.timestamp)

			let duration = 0
			if (extensionTime && extensionTime > 0) {
				duration = extensionTime
			} else if (
				hasTimestamps &&
				points[0].timestamp &&
				points[points.length - 1].timestamp
			) {
				duration =
					(points[points.length - 1].timestamp - points[0].timestamp) / 1000
			} else {
				duration = track.get_total_time ? track.get_total_time() : 0
			}

			setTrackPoints(points)

			if (points.length > 0) {
				setTrimStart(0)
				setTrimEnd(points.length - 1)
				calculateTrimmedStats(points, 0, points.length - 1)
			}

			setHasLoaded(true)
			setLoading(false)
		},
		[hasLoaded]
	)

	const calculateTrimmedStats = useCallback((points, start, end) => {
		if (!points || points.length === 0 || start >= end) {
			setTrimmedStats(null)
			return
		}

		const trimmedPoints = points.slice(start, end + 1)

		let distance = 0
		let elevationGain = 0
		let prevPoint = trimmedPoints[0]

		for (let i = 1; i < trimmedPoints.length; i++) {
			const currentPoint = trimmedPoints[i]
			const segmentDistance = calculateDistance(
				prevPoint.lat,
				prevPoint.lng,
				currentPoint.lat,
				currentPoint.lng
			)
			distance += segmentDistance

			if (currentPoint.elevation && prevPoint.elevation) {
				const elevationDiff = currentPoint.elevation - prevPoint.elevation
				if (elevationDiff > 0) {
					elevationGain += elevationDiff
				}
			}

			prevPoint = currentPoint
		}

		let duration = 0
		if (
			trimmedPoints[0].timestamp &&
			trimmedPoints[trimmedPoints.length - 1].timestamp
		) {
			const startTime = trimmedPoints[0].timestamp
			const endTime = trimmedPoints[trimmedPoints.length - 1].timestamp
			duration = (endTime - startTime) / 1000
		}

		const stats = {
			points: trimmedPoints.length,
			percentage: ((trimmedPoints.length / points.length) * 100).toFixed(1),
			startIndex: start,
			endIndex: end,
			distance: distance,
			duration: duration,
			elevationGain: elevationGain,
		}

		setTrimmedStats(stats)
	}, [])

	const calculateDistance = (lat1, lon1, lat2, lon2) => {
		const R = 6371000
		const dLat = ((lat2 - lat1) * Math.PI) / 180
		const dLon = ((lon2 - lon1) * Math.PI) / 180
		const a =
			Math.sin(dLat / 2) * Math.sin(dLat / 2) +
			Math.cos((lat1 * Math.PI) / 180) *
				Math.cos((lat2 * Math.PI) / 180) *
				Math.sin(dLon / 2) *
				Math.sin(dLon / 2)
		const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
		return R * c
	}

	const formatTime = seconds => {
		if (!seconds || seconds < 0) return '‚Äî'

		const hours = Math.floor(seconds / 3600)
		const minutes = Math.floor((seconds % 3600) / 60)
		const secs = Math.floor(seconds % 60)

		if (hours > 0) {
			return `${hours}:${minutes.toString().padStart(2, '0')}:${secs
				.toString()
				.padStart(2, '0')}`
		}
		return `${minutes}:${secs.toString().padStart(2, '0')}`
	}

	// –û–¥–∏–Ω —Å–ª–∞–π–¥–µ—Ä —Å –¥–≤—É–º—è –ø–æ–ª–∑—É–Ω–∫–∞–º–∏
	const handleRangeChange = useCallback(
		value => {
			const [start, end] = value
			const newStart = Math.min(start, trackPoints.length - 2)
			const newEnd = Math.max(end, 1)

			if (newStart >= newEnd) {
				// –ï—Å–ª–∏ –ø–æ–ª–∑—É–Ω–∫–∏ –ø–µ—Ä–µ—Å–µ–∫–ª–∏—Å—å, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º
				const middle = Math.floor((newStart + newEnd) / 2)
				const adjustedStart = Math.max(0, middle - 1)
				const adjustedEnd = Math.min(trackPoints.length - 1, middle + 1)

				setTrimStart(adjustedStart)
				setTrimEnd(adjustedEnd)
				setTimeout(() => {
					calculateTrimmedStats(trackPoints, adjustedStart, adjustedEnd)
				}, 0)
			} else {
				setTrimStart(newStart)
				setTrimEnd(newEnd)
				setTimeout(() => {
					calculateTrimmedStats(trackPoints, newStart, newEnd)
				}, 0)
			}
		},
		[trackPoints, calculateTrimmedStats]
	)

	const handleReset = () => {
		if (!trackPoints.length) return
		setTrimStart(0)
		setTrimEnd(trackPoints.length - 1)
		calculateTrimmedStats(trackPoints, 0, trackPoints.length - 1)
	}

	const handleSaveTrimmed = () => {
		setSaveModalVisible(true)
	}

	const handleMapReady = useCallback(mapInst => {
		setMapInstance(mapInst)
	}, [])

	if (!track) {
		return (
			<Alert
				message='–¢—Ä–µ–∫ –Ω–µ –≤—ã–±—Ä–∞–Ω'
				description="–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫ –∏–∑ —Å–ø–∏—Å–∫–∞ '–ú–æ–∏ —Ç—Ä–µ–∫–∏' –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"
				type='info'
				showIcon
				className={styles.alert}
			/>
		)
	}

	return (
		<div className={styles.container}>
			{/* –ö–∞—Ä—Ç–∞ */}
			<div className={styles.mapSection}>
				<TrackVisualizer
					gpxUrl={track.url}
					onTrackLoaded={handleTrackLoaded}
					onMapReady={handleMapReady}
					startMarker={trimStart}
					endMarker={trimEnd}
					trimmedSegment={
						trackPoints.length > 0 ? { start: trimStart, end: trimEnd } : null
					}
				/>
			</div>

			{loading && !hasLoaded ? (
				<div className={styles.loadingContainer}>
					<Spin size='large' />
					<div className={styles.loadingText}>–ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞...</div>
				</div>
			) : trackPoints.length > 0 ? (
				<>
					{/* –û–¥–∏–Ω —Å–ª–∞–π–¥–µ—Ä —Å –¥–≤—É–º—è –ø–æ–ª–∑—É–Ω–∫–∞–º–∏ */}
					<div className={styles.rangeSliderSection}>
						<Text
							strong
							style={{ fontSize: '12px', marginBottom: 8, display: 'block' }}
						>
							–í—ã–±–æ—Ä —É—á–∞—Å—Ç–∫–∞:
						</Text>
						<Slider
							range
							min={0}
							max={trackPoints.length - 1}
							value={[trimStart, trimEnd]}
							onChange={handleRangeChange}
							tooltip={{
								formatter: value => `–¢–æ—á–∫–∞ ${value + 1}`,
							}}
							className={styles.rangeSlider}
							trackStyle={[
								{ backgroundColor: '#d9d9d9' }, // –î–æ –Ω–∞—á–∞–ª–∞
								{ backgroundColor: '#52c41a' }, // –ú–µ–∂–¥—É –ø–æ–ª–∑—É–Ω–∫–∞–º–∏ (–∑–µ–ª–µ–Ω—ã–π)
								{ backgroundColor: '#d9d9d9' }, // –ü–æ—Å–ª–µ –∫–æ–Ω—Ü–∞
							]}
							handleStyle={[
								{
									borderColor: '#52c41a',
									backgroundColor: '#52c41a',
								},
								{
									borderColor: '#f5222d',
									backgroundColor: '#f5222d',
								},
							]}
							railStyle={{ backgroundColor: '#d9d9d9' }}
						/>
					</div>

					{/* –ü–ª–µ–µ—Ä –ø–æ–¥ –∫–∞—Ä—Ç–æ–π */}
					{mapInstance && trackPoints.length > 0 && (
						<div className={styles.playerSection}>
							<TrackPlayer
								trackPoints={trackPoints}
								startIndex={trimStart}
								endIndex={trimEnd}
								mapInstance={mapInstance}
								className={styles.fullWidthPlayer} // ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú
							/>
						</div>
					)}

					{/* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */}
					{trimmedStats && (
						<Card size='small' className={styles.statsCard}>
							<Row gutter={[16, 8]} align='middle' className={styles.statsRow}>
								<Col flex={1}>
									<Row gutter={[16, 8]} justify='space-between'>
										<Col>
											<Statistic
												title='–¢–æ—á–µ–∫'
												value={trimmedStats.points}
												suffix={`(${trimmedStats.percentage}%)`}
												size='small'
												className={styles.compactStat}
											/>
										</Col>
										<Col>
											<Statistic
												title='–î–∏—Å—Ç–∞–Ω—Ü–∏—è'
												value={(trimmedStats.distance / 1000).toFixed(2)}
												suffix='–∫–º'
												size='small'
												className={styles.compactStat}
											/>
										</Col>
										<Col>
											<Statistic
												title='–í—Ä–µ–º—è'
												value={formatTime(trimmedStats.duration)}
												size='small'
												className={styles.compactStat}
											/>
										</Col>
										<Col>
											<Statistic
												title='–ù–∞–±–æ—Ä –≤—ã—Å–æ—Ç—ã'
												value={
													trimmedStats.elevationGain
														? trimmedStats.elevationGain.toFixed(0)
														: '‚Äî'
												}
												suffix='–º'
												size='small'
												className={styles.compactStat}
											/>
										</Col>
									</Row>
								</Col>
								<Col style={{ flex: '0 0 auto' }}>
									<Space>
										<Button
											size='small'
											icon={<UndoOutlined />}
											onClick={handleReset}
											disabled={
												trimStart === 0 && trimEnd === trackPoints.length - 1
											}
										>
											–°–±—Ä–æ—Å
										</Button>
										<Button
											size='small'
											type='primary'
											icon={<SaveOutlined />}
											onClick={handleSaveTrimmed}
											loading={loading}
										>
											–°–æ—Ö—Ä–∞–Ω–∏—Ç—å
										</Button>
									</Space>
								</Col>
							</Row>
						</Card>
					)}
				</>
			) : null}

			<SaveTrackModal
				visible={saveModalVisible}
				onCancel={() => setSaveModalVisible(false)}
				onSave={handleSaveTrack}
				originalFilename={track.filename}
				loading={saving}
			/>
		</div>
	)
}



===== src/features/gpx-tools/ui/GpxList.jsx =====
import React, { useState } from 'react'
import {
	List,
	Card,
	Tag,
	Button,
	Space,
	Typography,
	Alert,
	Popconfirm,
	message,
	Tooltip,
	Empty,
} from 'antd'
import {
	PlayCircleOutlined,
	ScissorOutlined,
	SwapOutlined,
	SplitCellsOutlined,
	EyeOutlined,
	DeleteOutlined,
	DownloadOutlined,
	CheckCircleOutlined,
	EditOutlined,
} from '@ant-design/icons'
import dayjs from 'dayjs'
import styles from './GpxList.module.css'
import supabase from '../../../supabase' // ‚Üê –ü–£–¢–¨ –ú–û–ñ–ï–¢ –ë–´–¢–¨ –î–†–£–ì–ò–ú! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å

const { Text } = Typography

export default function GpxList({
	tracks,
	selectedTrack,
	onTrackSelect,
	onTrackDeleted,
	user,
	selectedTracks, // ‚Üê –î–æ–±–∞–≤–∏—Ç—å
	onTracksSelect, // ‚Üê –î–æ–±–∞–≤–∏—Ç—å
}) {
	const [loadingDelete, setLoadingDelete] = useState(null)
	const [editingTrackId, setEditingTrackId] = useState(null) // ‚Üê –î–û–ë–ê–í–ò–¢–¨
	const [editName, setEditName] = useState('') // ‚Üê –î–û–ë–ê–í–ò–¢–¨

	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
	const startEditing = (track, e) => {
		e?.stopPropagation()
		setEditingTrackId(track.id)
		setEditName(track.filename || '')
	}
	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–±–æ—Ä–∞/—Å–Ω—è—Ç–∏—è –≤—ã–±–æ—Ä–∞ —Ç—Ä–µ–∫–∞
	// –û–±–Ω–æ–≤–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é toggleTrackSelection
	const toggleTrackSelection = track => {
		const newSelectedTracks = selectedTracks.some(t => t.id === track.id)
			? selectedTracks.filter(t => t.id !== track.id)
			: selectedTracks.length >= 2
			? [...selectedTracks.slice(0, 1), track]
			: [...selectedTracks, track]

		// –ü–µ—Ä–µ–¥–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ç—Ä–µ–∫–∏ –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
		onTracksSelect?.(newSelectedTracks)
	}

	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏
	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏
	const saveEditName = async track => {
		if (!editName.trim()) {
			message.warning('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞')
			return
		}

		try {
			// 1. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π URL —Ñ–∞–π–ª–∞ –∏–∑ track
			const currentUrl = track.url

			// 2. –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –∏–∑ URL
			const urlParts = currentUrl.split('/')
			const oldFilePath = urlParts[urlParts.length - 1]

			// 3. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –∏–º—è —Ñ–∞–π–ª–∞ —Å .gpx
			const newFileName = editName.endsWith('.gpx')
				? editName
				: `${editName}.gpx`
			const newFilePath = oldFilePath.replace(/[^_]*$/, newFileName)

			console.log('–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ:', {
				old: oldFilePath,
				new: newFilePath,
				trackId: track.id,
			})

			// 4. –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª —Å –Ω–æ–≤—ã–º –∏–º–µ–Ω–µ–º –≤ Storage
			const { data: copyData, error: copyError } = await supabase.storage
				.from('gpx-tracks')
				.copy(oldFilePath, newFilePath)

			if (copyError) throw copyError

			// 5. –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤—ã–π –ø—É–±–ª–∏—á–Ω—ã–π URL
			const { data: urlData } = supabase.storage
				.from('gpx-tracks')
				.getPublicUrl(newFilePath)

			// 6. –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ lap_times
			const { error: updateError } = await supabase
				.from('lap_times')
				.update({
					comment: `–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω: ${newFileName}`, // –ò—Å–ø–æ–ª—å–∑—É–µ–º comment –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ
					gpx_track_url: urlData.publicUrl,
					updated_at: new Date().toISOString(),
				})
				.eq('id', track.id)

			if (updateError) throw updateError

			// 7. –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
			// const { error: deleteError } = await supabase.storage
			//   .from('gpx-tracks')
			//   .remove([oldFilePath]);
			// if (deleteError) console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª:', deleteError);

			message.success('–ù–∞–∑–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ')
			setEditingTrackId(null)
			onTrackDeleted?.() // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫
		} catch (error) {
			console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', error)
			message.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞–∑–≤–∞–Ω–∏—è: ${error.message}`)
		}
	}
	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
	const cancelEditing = () => {
		setEditingTrackId(null)
		setEditName('')
	}

	// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
	const formatTime = seconds => {
		const mins = Math.floor(seconds / 60)
		const secs = seconds % 60
		return `${mins}:${secs.toString().padStart(2, '0')}`
	}

	// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã
	const formatDate = dateString => {
		return dayjs(dateString).format('DD.MM.YYYY HH:mm')
	}

	// –£–¥–∞–ª–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞
	const handleDeleteTrack = async trackId => {
		setLoadingDelete(trackId)
		try {
			// TODO: –£–¥–∞–ª–∏—Ç—å –∏–∑ —Ç–∞–±–ª–∏—Ü—ã lap_times
			// TODO: –£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª –∏–∑ Storage
			message.success('–¢—Ä–µ–∫ —É–¥–∞–ª–µ–Ω')
			onTrackDeleted?.()
		} catch (error) {
			console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è:', error)
			message.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç—Ä–µ–∫–∞')
		} finally {
			setLoadingDelete(null)
		}
	}

	// –î–µ–π—Å—Ç–≤–∏—è —Å —Ç—Ä–µ–∫–æ–º
	const handleActionClick = (action, track, e) => {
		e.stopPropagation()

		switch (action) {
			case 'select':
				onTrackSelect(track)
				break
			case 'view':
				window.open(track.url, '_blank')
				break
			case 'download':
				// –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
				const link = document.createElement('a')
				link.href = track.url
				link.download = track.filename
				document.body.appendChild(link)
				link.click()
				document.body.removeChild(link)
				break
			case 'edit':
				onTrackSelect(track)
				break
			case 'play':
				onTrackSelect(track)
				break
			case 'compare':
				onTrackSelect(track)
				break
			case 'split':
				onTrackSelect(track)
				break
		}
	}

	if (tracks.length === 0) {
		return (
			<Empty
				image={Empty.PRESENTED_IMAGE_SIMPLE}
				description={
					<div className={styles.emptyContainer}>
						<Text type='secondary'>–£ –≤–∞—Å –µ—â–µ –Ω–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö GPX —Ç—Ä–µ–∫–æ–≤</Text>
						<Text type='secondary' className={styles.emptySubtext}>
							–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ç—Ä–µ–∫ —á–µ—Ä–µ–∑ –≤–∫–ª–∞–¥–∫—É "–î–æ–±–∞–≤–∏—Ç—å" –≤ —Ç–∞–±–ª–∏—Ü–µ –∑–∞–µ–∑–¥–æ–≤
						</Text>
					</div>
				}
			/>
		)
	}

	return (
		<div className={styles.container}>
			<List
				dataSource={tracks}
				renderItem={track => (
					<List.Item key={track.id}>
						<Card
							className={`${styles.trackCard} ${
								selectedTracks.some(t => t.id === track.id)
									? styles.selected
									: ''
							}`}
							onClick={() => toggleTrackSelection(track)}
						>
							<div className={styles.cardContent}>
								{/* –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è */}
								<div className={styles.mainInfo}>
									<div className={styles.trackHeader}>
										{editingTrackId === track.id ? (
											// –†–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
											<div className={styles.editContainer}>
												<input
													type='text'
													value={editName}
													onChange={e => setEditName(e.target.value)}
													onKeyDown={e => {
														if (e.key === 'Enter') saveEditName(track)
														if (e.key === 'Escape') cancelEditing()
													}}
													className={styles.nameInput}
													autoFocus
												/>
												<Space className={styles.editButtons}>
													<Button
														size='small'
														type='text'
														onClick={() => saveEditName(track)}
														className={styles.editButton}
														icon={<CheckCircleOutlined />}
													/>
													<Button
														size='small'
														type='text'
														onClick={cancelEditing}
														className={styles.editButton}
														icon={<DeleteOutlined />}
													/>
												</Space>
											</div>
										) : (
											// –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
											<>
												<Text strong className={styles.filename}>
													{track.filename}
												</Text>
											</>
										)}

										{track.verified && (
											<Tooltip title='–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω—ã–π —Ç—Ä–µ–∫'>
												<Tag
													icon={<CheckCircleOutlined />}
													color='success'
													className={styles.verifiedTag}
												>
													–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ
												</Tag>
											</Tooltip>
										)}
									</div>

									<div className={styles.metadata}>
										<Space size='large' wrap>
											<div className={styles.metaItem}>
												<Text type='secondary'>–î–∞—Ç–∞:</Text>
												<Text strong className={styles.metaValue}>
													{formatDate(track.date)}
												</Text>
											</div>

											<div className={styles.metaItem}>
												<Text type='secondary'>–í—Ä–µ–º—è:</Text>
												<Tag color='green' className={styles.timeTag}>
													{formatTime(track.time)}
												</Tag>
											</div>

											{track.skiModel && (
												<div className={styles.metaItem}>
													<Text type='secondary'>–õ—ã–∂–∏:</Text>
													<Text strong className={styles.metaValue}>
														{track.skiModel}
													</Text>
												</div>
											)}

											{track.comment && (
												<div className={styles.metaItem}>
													<Text type='secondary'>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</Text>
													<Text className={styles.comment}>
														{track.comment}
													</Text>
												</div>
											)}
										</Space>
									</div>
								</div>

								{/* –î–µ–π—Å—Ç–≤–∏—è */}
								<div className={styles.actions}>
									<Space wrap>
										<Tooltip title='–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ'>
											<Button
												size='small'
												onClick={e => startEditing(track, e)}
												icon={<EditOutlined />}
											/>
										</Tooltip>

										<Tooltip title='–°–∫–∞—á–∞—Ç—å GPX —Ñ–∞–π–ª'>
											<Button
												icon={<DownloadOutlined />}
												size='small'
												onClick={e => handleActionClick('download', track, e)}
											/>
										</Tooltip>

										<Tooltip title='–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–µ–∫'>
											<Button
												icon={<ScissorOutlined />}
												size='small'
												type={
													selectedTrack?.id === track.id ? 'primary' : 'default'
												}
												onClick={e => handleActionClick('edit', track, e)}
											/>
										</Tooltip>

										<Tooltip title='–°—Ä–∞–≤–Ω–∏—Ç—å —Å –¥—Ä—É–≥–∏–º'>
											<Button
												icon={<SwapOutlined />}
												size='small'
												onClick={e => handleActionClick('compare', track, e)}
											/>
										</Tooltip>

										<Tooltip title='–†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ –∫—Ä—É–≥–∏'>
											<Button
												icon={<SplitCellsOutlined />}
												size='small'
												onClick={e => handleActionClick('split', track, e)}
											/>
										</Tooltip>

										<Popconfirm
											title='–£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫?'
											description='–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ —É–¥–∞–ª–∏—Ç —Ç—Ä–µ–∫ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ —Ñ–∞–π–ª–æ–≤.'
											onConfirm={() => handleDeleteTrack(track.id)}
											okText='–î–∞, —É–¥–∞–ª–∏—Ç—å'
											cancelText='–û—Ç–º–µ–Ω–∞'
											okType='danger'
										>
											<Button
												icon={<DeleteOutlined />}
												size='small'
												danger
												loading={loadingDelete === track.id}
											/>
										</Popconfirm>
									</Space>
								</div>
							</div>
						</Card>
					</List.Item>
				)}
				className={styles.list}
			/>
		</div>
	)
}



===== src/features/gpx-tools/ui/GpxSplitter.jsx =====
import React from 'react'
import { Card, Alert, Typography, Button } from 'antd'
import { SplitCellsOutlined, RocketOutlined } from '@ant-design/icons'
import styles from './GpxSplitter.module.css'

const { Title, Text } = Typography

export default function GpxSplitter({ track, onTrackUpdated, user }) {
	if (!track) {
		return null
	}

	return (
		<Card className={styles.container}>
			<div className={styles.header}>
				<Title level={4} className={styles.title}>
					<SplitCellsOutlined /> –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –∫—Ä—É–≥–∏
				</Title>
				<Text type='secondary' className={styles.subtitle}>
					–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫—Ä—É–≥–æ–≤ –ø–æ —ç—Ç–∞–ª–æ–Ω–Ω–æ–º—É —Ç—Ä–µ–∫—É
				</Text>
			</div>

			<Alert
				message='–§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ'
				description='–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞ –Ω–∞ –∫—Ä—É–≥–∏ —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ.'
				type='info'
				showIcon
				className={styles.alert}
			/>

			<div className={styles.workflow}>
				<div className={styles.step}>
					<div className={styles.stepNumber}>1</div>
					<div className={styles.stepContent}>
						<Text strong>–ó–∞–≥—Ä—É–∑–∏—Ç–µ —ç—Ç–∞–ª–æ–Ω–Ω—ã–π —Ç—Ä–µ–∫</Text>
						<Text type='secondary'>GPX —Ñ–∞–π–ª —Å –æ–¥–Ω–∏–º –∏–¥–µ–∞–ª—å–Ω—ã–º –∫—Ä—É–≥–æ–º</Text>
					</div>
				</div>

				<div className={styles.arrow}>‚Üí</div>

				<div className={styles.step}>
					<div className={styles.stepNumber}>2</div>
					<div className={styles.stepContent}>
						<Text strong>–ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–∫–∞</Text>
						<Text type='secondary'>
							–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞—á–∞–ª–∞/–∫–æ–Ω—Ü–∞ –∫—Ä—É–≥–æ–≤
						</Text>
					</div>
				</div>

				<div className={styles.arrow}>‚Üí</div>

				<div className={styles.step}>
					<div className={styles.stepNumber}>3</div>
					<div className={styles.stepContent}>
						<Text strong>–í—ã–±–æ—Ä –∑–∞—á–µ—Ç–Ω–æ–≥–æ –∫—Ä—É–≥–∞</Text>
						<Text type='secondary'>–ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö –∫—Ä—É–≥–æ–≤ –∏ –≤—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ</Text>
					</div>
				</div>
			</div>

			<div className={styles.actions}>
				<Button type='primary' icon={<RocketOutlined />} size='large' disabled>
					–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ
				</Button>
				<Text type='secondary' className={styles.hint}>
					–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞: {track.filename}
				</Text>
			</div>
		</Card>
	)
}



===== src/features/gpx-tools/ui/GpxToolsPage.jsx =====
import React, { useState, useEffect } from 'react'
import { Card, Tabs, Spin, Alert, Typography, Space } from 'antd'
import {
	FileOutlined,
	ScissorOutlined,
	PlayCircleOutlined,
	SwapOutlined,
	SplitCellsOutlined,
} from '@ant-design/icons'
import { supabase } from '../../../shared/api/supabase'
import GpxList from './GpxList'
import GpxEditor from './GpxEditor'
import GpxComparator from './GpxComparator'
import GpxSplitter from './GpxSplitter'
import styles from './GpxToolsPage.module.css'

const { TabPane } = Tabs
const { Title, Text } = Typography

export default function GpxToolsPage({ user }) {
	const [loading, setLoading] = useState(true)
	const [tracks, setTracks] = useState([])
	const [selectedTrack, setSelectedTrack] = useState(null)
	const [activeTab, setActiveTab] = useState('list')
	const [selectedTracks, setSelectedTracks] = useState([])

	useEffect(() => {
		loadUserTracks()
	}, [user])

	async function loadUserTracks() {
		if (!user) {
			setLoading(false)
			return
		}

		try {
			setLoading(true)

			const { data: lapTimes, error } = await supabase
				.from('lap_times')
				.select('id, time_seconds, gpx_track_url, date, ski_model, comment')
				.eq('user_id', user.id)
				.not('gpx_track_url', 'is', null)
				.order('date', { ascending: false })

			if (error) throw error

			const formattedTracks = lapTimes.map(lap => ({
				id: lap.id,
				url: lap.gpx_track_url,
				time: lap.time_seconds,
				date: lap.date,
				skiModel: lap.ski_model,
				comment: lap.comment,
				filename: lap.gpx_track_url?.split('/').pop() || 'track.gpx',
			}))

			setTracks(formattedTracks)
		} catch (error) {
			console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç—Ä–µ–∫–æ–≤:', error)
		} finally {
			setLoading(false)
		}
	}
	// –î–æ–±–∞–≤—å—Ç–µ –ø–æ—Å–ª–µ loadUserTracks
	const handleTracksSelect = tracks => {
		setSelectedTracks(tracks)
	}
	const handleTrackSelect = track => {
		setSelectedTrack(track)
		// –î–ª—è –º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä–∞
		setSelectedTracks(prev => {
			if (prev.some(t => t.id === track.id)) {
				return prev.filter(t => t.id !== track.id)
			} else {
				if (prev.length >= 2) {
					return [...prev.slice(0, 1), track]
				} else {
					return [...prev, track]
				}
			}
		})
	}

	const handleTabChange = key => {
		setActiveTab(key)
	}

	if (loading) {
		return (
			<div className={styles.loadingContainer}>
				<Spin size='large' />
				<div className={styles.loadingText}>–ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–æ–≤...</div>
			</div>
		)
	}

	if (!user) {
		return (
			<Alert
				message='–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è'
				description='–î–ª—è —Ä–∞–±–æ—Ç—ã —Å GPX —Ç—Ä–µ–∫–∞–º–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤–æ–π—Ç–∏ –≤ —Å–∏—Å—Ç–µ–º—É.'
				type='warning'
				showIcon
				className={styles.authAlert}
			/>
		)
	}

	return (
		<Card className={styles.container}>
			{console.log('üîç GpxToolsPage –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä–∏–ª—Å—è, user:', user?.id)}
			<Space direction='vertical' size='small' className={styles.content}>
				<Tabs
					activeKey={activeTab}
					onChange={handleTabChange}
					type='card'
					size='small'
					className={styles.tabs}
				>
					<TabPane
						tab={
							<span className={styles.tabLabel}>
								<FileOutlined /> –ú–æ–∏ —Ç—Ä–µ–∫–∏
							</span>
						}
						key='list'
					>
						<GpxList
							tracks={tracks}
							selectedTrack={selectedTrack}
							selectedTracks={selectedTracks}
							onTrackSelect={handleTrackSelect}
							onTracksSelect={handleTracksSelect}
							onTrackDeleted={loadUserTracks}
							user={user}
						/>
					</TabPane>

					<TabPane
						tab={
							<span className={styles.tabLabel}>
								<ScissorOutlined /> –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
							</span>
						}
						key='edit'
						disabled={selectedTracks.length !== 1} // ‚Üê –ò–ó–ú–ï–ù–ò–¢–¨: —Ç–æ–ª—å–∫–æ 1 —Ç—Ä–µ–∫
					>
						{selectedTracks.length === 1 ? (
							<GpxEditor
								track={selectedTracks[0]} // ‚Üê –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ç—Ä–µ–∫
								onTrackUpdated={loadUserTracks}
								user={user}
							/>
						) : (
							<Alert
								message='–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω —Ç—Ä–µ–∫'
								description='–î–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω —Ç—Ä–µ–∫'
								type='info'
								showIcon
							/>
						)}
					</TabPane>

					<TabPane
						tab={
							<span className={styles.tabLabel}>
								<SwapOutlined /> –°—Ä–∞–≤–Ω–∏—Ç—å
							</span>
						}
						key='compare'
						disabled={selectedTracks.length !== 2} // ‚Üê –ò–ó–ú–ï–ù–ò–¢–¨: —Ä–æ–≤–Ω–æ 2 —Ç—Ä–µ–∫–∞
					>
						{selectedTracks.length === 2 ? (
							<GpxComparator tracks={selectedTracks} user={user} />
						) : (
							<Alert
								message='–í—ã–±–µ—Ä–∏—Ç–µ –¥–≤–∞ —Ç—Ä–µ–∫–∞'
								description='–î–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –≤—ã–±–µ—Ä–∏—Ç–µ –¥–≤–∞ —Ç—Ä–µ–∫–∞'
								type='info'
								showIcon
							/>
						)}
					</TabPane>

					<TabPane
						tab={
							<span className={styles.tabLabel}>
								<SplitCellsOutlined /> –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ –∫—Ä—É–≥–∏
							</span>
						}
						key='split'
						disabled={selectedTracks.length !== 1} // ‚Üê –ò–ó–ú–ï–ù–ò–¢–¨: —Ç–æ–ª—å–∫–æ 1 —Ç—Ä–µ–∫
					>
						{selectedTracks.length === 1 ? (
							<GpxSplitter
								track={selectedTracks[0]} // ‚Üê –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ç—Ä–µ–∫
								onTrackUpdated={loadUserTracks}
								user={user}
							/>
						) : (
							<Alert
								message='–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω —Ç—Ä–µ–∫'
								description='–î–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω —Ç—Ä–µ–∫'
								type='info'
								showIcon
							/>
						)}
					</TabPane>
				</Tabs>
				{!selectedTrack && activeTab !== 'list' && (
					<Alert
						message='–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫'
						description="–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫ –∏–∑ —Å–ø–∏—Å–∫–∞ '–ú–æ–∏ —Ç—Ä–µ–∫–∏'"
						type='info'
						showIcon
						className={styles.selectAlert}
					/>
				)}
			</Space>
		</Card>
	)
}



===== src/features/gpx-tools/ui/components/SaveTrackModal.jsx =====
import React, { useState, useEffect } from 'react'
import {
	Modal,
	Form,
	Input,
	Radio,
	Space,
	Alert,
	Typography,
	message,
} from 'antd'
import { SaveOutlined, WarningOutlined } from '@ant-design/icons'

const { Text } = Typography

const SaveTrackModal = ({
	visible,
	onCancel,
	onSave,
	originalFilename,
	loading = false,
}) => {
	const [form] = Form.useForm()
	const [saveOption, setSaveOption] = useState('new') // 'new' –∏–ª–∏ 'overwrite'

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ —Å timestamp
	const generateFilename = baseName => {
		if (!baseName) return 'track.gpx'
		const nameWithoutExt = baseName.replace(/\.gpx$/i, '')
		const timestamp = new Date()
			.toLocaleString('ru-RU', {
				month: '2-digit',
				day: '2-digit',
				hour: '2-digit',
				minute: '2-digit',
			})
			.replace(/[:\s]/g, '_')
			.replace(/\//g, '-')
		return `${nameWithoutExt}_${timestamp}.gpx`
	}

	// –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–æ—Ä–º—É –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
	useEffect(() => {
		if (visible) {
			const suggestedName = generateFilename(originalFilename)
			form.setFieldsValue({
				filename: suggestedName,
				description: '',
				saveOption: 'new',
			})
			setSaveOption('new')
		}
	}, [visible, originalFilename, form])

	const handleOptionChange = e => {
		const value = e.target.value
		setSaveOption(value)

		// –ï—Å–ª–∏ –ø–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –Ω–∞ "–Ω–æ–≤—ã–π", –æ–±–Ω–æ–≤–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞
		if (value === 'new') {
			const suggestedName = generateFilename(originalFilename)
			form.setFieldValue('filename', suggestedName)
		}
	}

	const handleOk = async () => {
		try {
			const values = await form.validateFields()

			// –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —É —Ñ–∞–π–ª–∞ –µ—Å—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ .gpx
			let filename = values.filename || ''
			if (saveOption === 'new') {
				// –î–æ–±–∞–≤–ª—è–µ–º .gpx –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
				if (filename && !filename.toLowerCase().endsWith('.gpx')) {
					filename = filename + '.gpx'
				}

				// –ï—Å–ª–∏ –∏–º—è –ø—É—Å—Ç–æ–µ, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
				if (!filename || filename === '.gpx') {
					filename = generateFilename(originalFilename)
				}
			} else {
				// –î–ª—è –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è
				filename = originalFilename || 'track.gpx'
			}

			onSave({
				filename: filename,
				description: values.description || '',
				saveOption: saveOption,
			})
		} catch (error) {
			console.error('–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ñ–æ—Ä–º—ã:', error)
		}
	}

	return (
		<Modal
			title={
				<Space>
					<SaveOutlined />
					<span>–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞</span>
				</Space>
			}
			open={visible}
			onOk={handleOk}
			onCancel={onCancel}
			confirmLoading={loading}
			okText='–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'
			cancelText='–û—Ç–º–µ–Ω–∞'
			width={500}
			destroyOnClose
		>
			<Form form={form} layout='vertical'>
				<Form.Item name='saveOption'>
					<Radio.Group onChange={handleOptionChange} style={{ width: '100%' }}>
						<Space direction='vertical' style={{ width: '100%' }}>
							<Radio value='new' style={{ display: 'block', marginBottom: 8 }}>
								<Text strong>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ –Ω–æ–≤—ã–π —Ç—Ä–µ–∫</Text>
								<br />
								<Text type='secondary'>
									–°–æ–∑–¥–∞—Å—Ç –∫–æ–ø–∏—é —Ç—Ä–µ–∫–∞ —Å –Ω–æ–≤—ã–º –∏–º–µ–Ω–µ–º —Ñ–∞–π–ª–∞
								</Text>
							</Radio>

							<Radio value='overwrite' style={{ display: 'block' }}>
								<Text strong>–ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å —Ç–µ–∫—É—â–∏–π —Ç—Ä–µ–∫</Text>
								<br />
								<Text type='secondary'>
									–ó–∞–º–µ–Ω—è–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª (—Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã)
								</Text>
							</Radio>
						</Space>
					</Radio.Group>
				</Form.Item>

				{saveOption === 'new' && (
					<Form.Item
						label='–ò–º—è —Ñ–∞–π–ª–∞'
						name='filename'
						rules={[
							{ required: true, message: '–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞' },
							{
								pattern: /^[^.]*$/i, // ‚Üê –ò–ó–ú–ï–ù–ò–õ–ò: –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º .gpx –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞
								message:
									'–ù–µ —É–∫–∞–∑—ã–≤–∞–π—Ç–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ .gpx - –æ–Ω–æ –¥–æ–±–∞–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏',
							},
						]}
						help='–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ .gpx –¥–æ–±–∞–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏'
						extra={`–ü—Ä–∏–º–µ—Ä: ${generateFilename(originalFilename)}`}
					>
						<Input placeholder='–Ω–∞–ø—Ä–∏–º–µ—Ä: my_track_edited' addonAfter='.gpx' />
					</Form.Item>
				)}

				{saveOption === 'overwrite' && (
					<Alert
						message='–í–Ω–∏–º–∞–Ω–∏–µ!'
						description='–í—ã –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫. –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.'
						type='warning'
						showIcon
						icon={<WarningOutlined />}
						style={{ marginBottom: 16 }}
					/>
				)}

				<Form.Item label='–û–ø–∏—Å–∞–Ω–∏–µ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)' name='description'>
					<Input.TextArea
						rows={3}
						placeholder='–î–æ–±–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π...'
						maxLength={500}
						showCount
					/>
				</Form.Item>
			</Form>
		</Modal>
	)
}

export default SaveTrackModal



===== src/features/gpx-tools/ui/components/TrackPlayer.jsx =====
import React, { useState, useEffect, useRef, useCallback } from 'react'
import {
	Card,
	Slider,
	Button,
	Space,
	Typography,
	Row,
	Col,
	Statistic,
	Select,
	Progress,
	Tooltip,
} from 'antd'
import {
	PlayCircleOutlined,
	PauseCircleOutlined,
	ForwardOutlined,
	BackwardOutlined,
	LineChartOutlined,
	RocketOutlined,
} from '@ant-design/icons'
import L from 'leaflet'
import styles from './TrackPlayer.module.css'

const { Text } = Typography
const { Option } = Select

const TrackPlayer = ({
	trackPoints,
	startIndex = 0,
	endIndex = null,
	onTimeUpdate,
	mapInstance,
}) => {
	const [isPlaying, setIsPlaying] = useState(false)
	const [currentPointIndex, setCurrentPointIndex] = useState(startIndex)
	const [playbackSpeed, setPlaybackSpeed] = useState(75)
	const [progress, setProgress] = useState(0)
	const [stats, setStats] = useState(null)
	const [currentSpeed, setCurrentSpeed] = useState('‚Äî')

	const playerIntervalRef = useRef(null)
	const markerRef = useRef(null)
	const startTimeRef = useRef(null)
	const lastSpeedRef = useRef('‚Äî')
	const [pauseTime, setPauseTime] = useState(0) // ‚Üê –î–û–ë–ê–í–ò–ú
	const [accumulatedTime, setAccumulatedTime] = useState(0) // ‚Üê –î–û–ë–ê–í–ò–ú
	const [maxSpeedPoint, setMaxSpeedPoint] = useState(null) // –¢–æ—á–∫–∞ —Å –º–∞–∫—Å. —Å–∫–æ—Ä–æ—Å—Ç—å—é

	const totalPoints = endIndex || trackPoints.length - 1
	const effectivePoints = trackPoints.slice(startIndex, totalPoints + 1)

	//useEffect —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å –ø–æ–∏—Å–∫–æ–º —Ç–æ—á–∫–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏:
	useEffect(() => {
		if (effectivePoints.length < 2) return

		// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –∏ —Å–∫–æ—Ä–æ—Å—Ç–∏
		let totalDistance = 0
		const speeds = []
		let prevPoint = effectivePoints[0]
		let maxSpeed = 0
		let maxSpeedIndex = -1 // ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú
		let maxSpeedPointData = null // ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú

		for (let i = 1; i < effectivePoints.length; i++) {
			const currentPoint = effectivePoints[i]
			const distance = calculateDistance(
				prevPoint.lat,
				prevPoint.lng,
				currentPoint.lat,
				currentPoint.lng
			)
			totalDistance += distance

			// –†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –µ—Å–ª–∏ –µ—Å—Ç—å –≤—Ä–µ–º—è
			if (prevPoint.timestamp && currentPoint.timestamp) {
				const timeDiff = (currentPoint.timestamp - prevPoint.timestamp) / 1000 // —Å–µ–∫—É–Ω–¥—ã
				if (timeDiff > 0) {
					const speed = (distance / timeDiff) * 3.6 // –∫–º/—á
					speeds.push(speed)

					// ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú: –∑–∞–ø–æ–º–∏–Ω–∞–µ–º —Ç–æ—á–∫—É –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
					if (speed > maxSpeed) {
						maxSpeed = speed
						maxSpeedIndex = i // –ò–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–π —Ç–æ—á–∫–∏
						maxSpeedPointData = {
							point: currentPoint, // –¢–æ—á–∫–∞, –≥–¥–µ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è —Å–µ–≥–º–µ–Ω—Ç —Å –º–∞–∫—Å. —Å–∫–æ—Ä–æ—Å—Ç—å—é
							speed: speed.toFixed(1),
							index: i + startIndex, // –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å –≤ —Ç—Ä–µ–∫–µ
							distance: distance,
							timeDiff: timeDiff,
						}
					}
				}
			}

			prevPoint = currentPoint
		}

		// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ—á–∫—É –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
		if (maxSpeedPointData) {
			setMaxSpeedPoint(maxSpeedPointData)
		}

		// –†–∞—Å—á–µ—Ç —Å—Ä–µ–¥–Ω–µ–π –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
		const avgSpeed =
			speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0

		setStats({
			totalDistance,
			avgSpeed: avgSpeed.toFixed(1),
			maxSpeed: maxSpeed.toFixed(1),
			points: effectivePoints.length,
		})
	}, [effectivePoints, startIndex])

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—Ä–∫–µ—Ä–∞
	useEffect(() => {
		if (!mapInstance || effectivePoints.length === 0) return

		// –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –º–∞—Ä–∫–µ—Ä
		if (markerRef.current) {
			mapInstance.removeLayer(markerRef.current)
		}

		// ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú: —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –º–µ–¥–∞–ª—å–∫—É
		if (window.maxSpeedMarker) {
			mapInstance.removeLayer(window.maxSpeedMarker)
			window.maxSpeedMarker = null
		}

		// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä (–∑–µ–ª–µ–Ω—ã–π –∫—Ä—É–∂–æ–∫)
		const icon = L.divIcon({
			className: styles.playerMarker,
			html: `
			<div style="
				width: 16px;
				height: 16px;
				background: #52c41a;
				border-radius: 50%;
				border: 3px solid white;
				box-shadow: 0 0 8px rgba(0,0,0,0.5);
				animation: pulse 2s infinite;
			">
				<style>
					@keyframes pulse {
						0% { box-shadow: 0 0 0 0 rgba(82, 196, 26, 0.7); }
						70% { box-shadow: 0 0 0 10px rgba(82, 196, 26, 0); }
						100% { box-shadow: 0 0 0 0 rgba(82, 196, 26, 0); }
					}
				</style>
			</div>
		`,
			iconSize: [22, 22],
			iconAnchor: [11, 11],
		})

		const currentPoint = effectivePoints[currentPointIndex - startIndex]
		if (currentPoint) {
			markerRef.current = L.marker([currentPoint.lat, currentPoint.lng], {
				icon,
			})
				.addTo(mapInstance)
				.bindPopup(`–¢–æ—á–∫–∞ ${currentPointIndex + 1}`)
		}

		// ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú: —Å–æ–∑–¥–∞–µ–º –º–∞—Ä–∫–µ—Ä –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ (–º–µ–¥–∞–ª—å–∫–∞)
		if (maxSpeedPoint && maxSpeedPoint.point) {
			const medalIcon = L.divIcon({
				className: styles.medalMarker,
				html: `
    <div style="
      position: relative;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    ">
      <!-- –ó–æ–ª–æ—Ç–∞—è –º–µ–¥–∞–ª—å–∫–∞ -->
      <div style="
        width: 24px;
        height: 24px;
        background: radial-gradient(circle at 30% 30%, #FFD700, #FFA500);
        border-radius: 50%;
        border: 2px solid #FFF;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        position: relative;
        z-index: 2;
      ">
        üèÜ
      </div>
      <!-- –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏ -->
      <div style="
        position: absolute;
        top: -8px;
        left: -8px;
        width: 46px;
        height: 46px;
        border-radius: 50%;
        border: 2px solid #FFD700;
        animation: pulseMedal 2s infinite;
        z-index: 1;
      ">
        <style>
          @keyframes pulseMedal {
            0% { transform: scale(1); opacity: 1; }
            70% { transform: scale(1.4); opacity: 0; }
            100% { transform: scale(1.4); opacity: 0; }
          }
        </style>
      </div>
    </div>
  `,
				iconSize: [30, 30], // ‚Üê –§–ò–ö–°–ò–†–û–í–ê–ù–ù–´–ô –†–ê–ó–ú–ï–†
				iconAnchor: [15, 15], // ‚Üê –¶–ï–ù–¢–†–ò–†–û–í–ê–ù–ò–ï (15 = 30/2)
				popupAnchor: [0, -15], // ‚Üê POPUP –ü–û–Ø–í–õ–Ø–ï–¢–°–Ø –ù–ê–î –ú–ê–†–ö–ï–†–û–ú
			})

			window.maxSpeedMarker = L.marker(
				[maxSpeedPoint.point.lat, maxSpeedPoint.point.lng],
				{
					icon: medalIcon,
					zIndexOffset: 1000,
				}
			).addTo(mapInstance).bindPopup(`
    <div style="font-size: 12px; text-align: center; min-width: 120px;">
      <strong>üèÜ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å</strong><br>
      ${maxSpeedPoint.speed} –∫–º/—á<br>
      –¢–æ—á–∫–∞: ${maxSpeedPoint.index + 1}
    </div>
  `)
		}

		return () => {
			if (markerRef.current && mapInstance) {
				mapInstance.removeLayer(markerRef.current)
			}
			// ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú: –æ—á–∏—â–∞–µ–º –º–µ–¥–∞–ª—å–∫—É –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
			if (window.maxSpeedMarker && mapInstance) {
				mapInstance.removeLayer(window.maxSpeedMarker)
				window.maxSpeedMarker = null
			}
		}
	}, [
		mapInstance,
		currentPointIndex,
		effectivePoints,
		startIndex,
		maxSpeedPoint,
	])

	const calculateDistance = (lat1, lon1, lat2, lon2) => {
		const R = 6371000
		const dLat = ((lat2 - lat1) * Math.PI) / 180
		const dLon = ((lon2 - lon1) * Math.PI) / 180
		const a =
			Math.sin(dLat / 2) * Math.sin(dLat / 2) +
			Math.cos((lat1 * Math.PI) / 180) *
				Math.cos((lat2 * Math.PI) / 180) *
				Math.sin(dLon / 2) *
				Math.sin(dLon / 2)
		const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
		const distance = R * c

		// –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (–º–µ–Ω—å—à–µ 1–º - —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ —à—É–º)
		return distance < 1 ? 0 : distance
	}

	const startPlayback = () => {
		if (isPlaying) return

		setIsPlaying(true)

		// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è, –∫–æ—Ç–æ—Ä–æ–µ –¥–æ–ª–∂–Ω–æ –±—ã–ª–æ –ø—Ä–æ–π—Ç–∏ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ç–æ—á–∫–∏
		const pointsFromStart = currentPointIndex - startIndex
		const timeForCurrentPoint = (pointsFromStart / playbackSpeed) * 1000

		startTimeRef.current = Date.now() - timeForCurrentPoint
		speedBufferRef.current = [] // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –±—É—Ñ–µ—Ä —Å–∫–æ—Ä–æ—Å—Ç–µ–π

		playerIntervalRef.current = setInterval(() => {
			const elapsed = Date.now() - startTimeRef.current
			const pointsPerSecond = playbackSpeed
			const pointsToAdvance = Math.floor((elapsed * pointsPerSecond) / 1000)

			let newIndex = startIndex + pointsToAdvance
			if (newIndex > totalPoints) {
				newIndex = totalPoints
				stopPlayback()
			}

			setCurrentPointIndex(newIndex)
			const newProgress =
				((newIndex - startIndex) / (totalPoints - startIndex)) * 100
			setProgress(newProgress)

			if (markerRef.current && effectivePoints[newIndex - startIndex]) {
				const point = effectivePoints[newIndex - startIndex]
				markerRef.current.setLatLng([point.lat, point.lng])

				// –ü–æ–ª—É—á–∞–µ–º —Å–≥–ª–∞–∂–µ–Ω–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
				const rawSpeed = calculateCurrentSpeed(newIndex)

				if (rawSpeed !== '‚Äî' && rawSpeed !== '0.0') {
					// –î–æ–±–∞–≤–ª—è–µ–º –≤ –±—É—Ñ–µ—Ä
					const speedValue = parseFloat(rawSpeed)
					if (!isNaN(speedValue)) {
						speedBufferRef.current.push(speedValue)

						// –î–µ—Ä–∂–∏–º –±—É—Ñ–µ—Ä –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
						if (speedBufferRef.current.length > BUFFER_SIZE) {
							speedBufferRef.current.shift()
						}

						// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ä–µ–¥–Ω–µ–µ
						const avgSpeed =
							speedBufferRef.current.length > 0
								? (
										speedBufferRef.current.reduce((a, b) => a + b, 0) /
										speedBufferRef.current.length
								  ).toFixed(1)
								: rawSpeed

						setCurrentSpeed(avgSpeed)
					} else {
						setCurrentSpeed(rawSpeed)
					}
				} else {
					setCurrentSpeed(rawSpeed)
				}
			}

			onTimeUpdate?.(newIndex)
		}, 100)
	}

	const stopPlayback = () => {
		setIsPlaying(false)

		if (playerIntervalRef.current) {
			clearInterval(playerIntervalRef.current)
			playerIntervalRef.current = null
			startTimeRef.current = null // ‚Üê –°–ë–†–ê–°–´–í–ê–ï–ú –í–†–ï–ú–Ø –ù–ê–ß–ê–õ–ê
		}
	}

	const calculateCurrentSpeed = useCallback(
		pointIndex => {
			if (
				pointIndex <= startIndex ||
				pointIndex >= effectivePoints.length + startIndex - 1
			) {
				return '0.0'
			}

			// 1. –ò–°–ü–û–õ–¨–ó–£–ï–ú –°–†–ï–î–ù–Æ–Æ –°–ö–û–†–û–°–¢–¨ –ù–ê –ü–†–û–ú–ï–ñ–£–¢–ö–ï (5 —Ç–æ—á–µ–∫ –≤–ø–µ—Ä–µ–¥)
			const lookbackPoints = 3 // –ë–µ—Ä–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–æ—á–µ–∫
			const lookforwardPoints = 2 // –ò –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ª–µ–¥—É—é—â–∏—Ö

			let totalDistance = 0
			let totalTime = 0
			let validPoints = 0

			// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ—á–µ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
			const minIndex = Math.max(startIndex, pointIndex - lookbackPoints)
			const maxIndex = Math.min(totalPoints, pointIndex + lookforwardPoints)

			if (maxIndex - minIndex < 2) {
				return calculateInstantSpeed(pointIndex) // –ï—Å–ª–∏ –º–∞–ª–æ —Ç–æ—á–µ–∫, –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–≥–Ω–æ–≤–µ–Ω–Ω—É—é
			}

			// 2. –°—á–∏—Ç–∞–µ–º –æ–±—â–µ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∏ –≤—Ä–µ–º—è –Ω–∞ –ø—Ä–æ–º–µ–∂—É—Ç–∫–µ
			for (let i = minIndex; i < maxIndex; i++) {
				const currentIdx = i
				const nextIdx = i + 1

				if (
					currentIdx < startIndex ||
					nextIdx > maxIndex ||
					currentIdx >= effectivePoints.length + startIndex - 1
				) {
					continue
				}

				const prevPoint = effectivePoints[currentIdx - startIndex]
				const currentPoint = effectivePoints[nextIdx - startIndex]

				if (!prevPoint || !currentPoint) continue

				// –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è —Ç–æ—á–µ–∫
				let prevTime =
					prevPoint.timestamp ||
					(prevPoint.time ? new Date(prevPoint.time).getTime() : null)
				let currTime =
					currentPoint.timestamp ||
					(currentPoint.time ? new Date(currentPoint.time).getTime() : null)

				if (!prevTime || !currTime || prevTime === currTime) continue

				// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
				const distance = calculateDistance(
					prevPoint.lat,
					prevPoint.lng,
					currentPoint.lat,
					currentPoint.lng
				)

				const timeDiff = (currTime - prevTime) / 1000 // —Å–µ–∫—É–Ω–¥—ã

				if (timeDiff <= 0) continue

				totalDistance += distance
				totalTime += timeDiff
				validPoints++
			}

			// 3. –ï—Å–ª–∏ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—á–∏—Ç–∞—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–µ–¥–Ω—é—é —Å–∫–æ—Ä–æ—Å—Ç—å
			if (validPoints > 0 && totalTime > 0) {
				return ((totalDistance / totalTime) * 3.6).toFixed(1) // –∫–º/—á
			}

			// 4. –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–≥–Ω–æ–≤–µ–Ω–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
			return calculateInstantSpeed(pointIndex)
		},
		[effectivePoints, startIndex]
	)

	// –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
	const calculateInstantSpeed = useCallback(
		pointIndex => {
			if (
				pointIndex <= startIndex ||
				pointIndex >= effectivePoints.length + startIndex - 1
			) {
				return '0.0'
			}

			const prevPoint = effectivePoints[pointIndex - 1 - startIndex]
			const currentPoint = effectivePoints[pointIndex - startIndex]

			if (!prevPoint || !currentPoint) return '‚Äî'

			let prevTime =
				prevPoint.timestamp ||
				(prevPoint.time ? new Date(prevPoint.time).getTime() : null)
			let currTime =
				currentPoint.timestamp ||
				(currentPoint.time ? new Date(currentPoint.time).getTime() : null)

			if (!prevTime || !currTime || prevTime === currTime) return '‚Äî'

			const distance = calculateDistance(
				prevPoint.lat,
				prevPoint.lng,
				currentPoint.lat,
				currentPoint.lng
			)
			const timeDiff = (currTime - prevTime) / 1000

			if (timeDiff <= 0) return '‚Äî'

			return ((distance / timeDiff) * 3.6).toFixed(1)
		},
		[effectivePoints, startIndex]
	)

	// –î–æ–±–∞–≤–ª—è–µ–º useRef –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–∫–æ—Ä–æ—Å—Ç–µ–π (—Å–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ)
	const speedBufferRef = useRef([])
	const BUFFER_SIZE = 5 // –†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è

	const handleSpeedChange = value => {
		setPlaybackSpeed(value)
		// setAccumulatedTime(0) ‚Üê –£–î–ê–õ–ò–¢–¨

		if (isPlaying) {
			stopPlayback()
			setTimeout(() => startPlayback(), 10)
		}
	}

	const handleSeek = value => {
		const newIndex =
			Math.floor((value / 100) * (totalPoints - startIndex)) + startIndex
		setCurrentPointIndex(newIndex)
		setProgress(value)

		if (markerRef.current && effectivePoints[newIndex - startIndex]) {
			const point = effectivePoints[newIndex - startIndex]
			markerRef.current.setLatLng([point.lat, point.lng])
			const speed = calculateCurrentSpeed(newIndex)
			setCurrentSpeed(speed)
		}

		if (isPlaying) {
			stopPlayback()
			setTimeout(() => startPlayback(), 10)
		}
	}

	const handleStepForward = () => {
		const stepSize = Math.max(1, Math.floor(playbackSpeed / 10))
		const newIndex = Math.min(currentPointIndex + stepSize, totalPoints)
		setCurrentPointIndex(newIndex)
		setProgress(((newIndex - startIndex) / (totalPoints - startIndex)) * 100)

		const speed = calculateCurrentSpeed(newIndex)
		setCurrentSpeed(speed)

		// –ï—Å–ª–∏ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏–µ –±—ã–ª–æ –∞–∫—Ç–∏–≤–Ω–æ, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Å –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
		if (isPlaying) {
			stopPlayback()
			setTimeout(() => startPlayback(), 10)
		}
	}

	const handleStepBackward = () => {
		const stepSize = Math.max(1, Math.floor(playbackSpeed / 10))
		const newIndex = Math.max(currentPointIndex - stepSize, startIndex)
		setCurrentPointIndex(newIndex)
		setProgress(((newIndex - startIndex) / (totalPoints - startIndex)) * 100)

		const speed = calculateCurrentSpeed(newIndex)
		setCurrentSpeed(speed)

		// –ï—Å–ª–∏ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏–µ –±—ã–ª–æ –∞–∫—Ç–∏–≤–Ω–æ, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Å –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
		if (isPlaying) {
			stopPlayback()
			setTimeout(() => startPlayback(), 10)
		}
	}

	// useEffect –æ—á–∏—Å—Ç–∫–∏:
	useEffect(() => {
		return () => {
			if (playerIntervalRef.current) {
				clearInterval(playerIntervalRef.current)
			}
			if (markerRef.current && mapInstance) {
				mapInstance.removeLayer(markerRef.current)
			}
			// ‚Üê –î–û–ë–ê–í–õ–Ø–ï–ú: –æ—á–∏—â–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –º–µ–¥–∞–ª—å–∫—É
			if (window.maxSpeedMarker && mapInstance) {
				mapInstance.removeLayer(window.maxSpeedMarker)
				window.maxSpeedMarker = null
			}
		}
	}, [mapInstance])

	return (
		<Card size='small' className={styles.container}>
			{/* –ü–ï–†–í–ê–Ø –°–¢–†–û–ö–ê: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å */}
			<div className={styles.firstRow}>
				<Space size='middle' className={styles.controlsGroup}>
					<Button
						size='small'
						icon={<BackwardOutlined />}
						onClick={handleStepBackward}
						disabled={currentPointIndex <= startIndex}
					/>

					<Button
						size='small'
						type={isPlaying ? 'default' : 'primary'}
						icon={isPlaying ? <PauseCircleOutlined /> : <PlayCircleOutlined />}
						onClick={isPlaying ? stopPlayback : startPlayback}
					/>

					<Button
						size='small'
						icon={<ForwardOutlined />}
						onClick={handleStepForward}
						disabled={currentPointIndex >= totalPoints}
					/>

					<Tooltip title='–°–∫–æ—Ä–æ—Å—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è'>
						<Select
							value={playbackSpeed}
							onChange={handleSpeedChange}
							size='small'
							style={{ width: 90 }}
							dropdownMatchSelectWidth={false}
						>
							<Option value={1}>1x</Option>
							<Option value={50}>50x</Option>
							<Option value={75}>75x</Option>
							<Option value={100}>100x</Option>
						</Select>
					</Tooltip>
				</Space>

				<Space size='middle' className={styles.statsGroup}>
					<Tooltip title='–¢–µ–∫—É—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å'>
						<div className={styles.speedDisplay}>
							<LineChartOutlined style={{ color: '#52c41a', marginRight: 4 }} />
							<Text strong style={{ fontSize: '14px', color: '#52c41a' }}>
								{currentSpeed} –∫–º/—á
							</Text>
						</div>
					</Tooltip>
				</Space>
			</div>

			{/* –í–¢–û–†–ê–Ø –°–¢–†–û–ö–ê: –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä */}
			<div className={styles.secondRow}>
				<Slider
					value={progress}
					onChange={handleSeek}
					tooltip={{ formatter: value => `${value.toFixed(0)}%` }}
					className={styles.progressSlider}
				/>
			</div>

			{/* –¢–†–ï–¢–¨–Ø –°–¢–†–û–ö–ê: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –º–µ—Å—Ç–æ) */}
			{stats && (
				<div className={styles.thirdRow}>
					<Row gutter={[8, 8]} justify='space-between'>
						<Col>
							<Statistic
								title='–î–∏—Å—Ç–∞–Ω—Ü–∏—è'
								value={(stats.totalDistance / 1000).toFixed(2)}
								suffix='–∫–º'
								size='small'
								valueStyle={{ fontSize: '12px' }}
							/>
						</Col>
						<Col>
							<Statistic
								title='–°—Ä–µ–¥–Ω—è—è'
								value={stats.avgSpeed}
								suffix='–∫–º/—á'
								size='small'
								valueStyle={{ fontSize: '12px' }}
							/>
						</Col>
						<Col>
							<Statistic
								title='–ú–∞–∫—Å.'
								value={stats.maxSpeed}
								suffix='–∫–º/—á'
								size='small'
								valueStyle={{ fontSize: '12px' }}
							/>
						</Col>
					</Row>
				</div>
			)}
		</Card>
	)
}

export default TrackPlayer



===== src/features/gpx-tools/ui/components/TrackVisualizer.jsx =====
import React, { useEffect, useRef, useState } from 'react'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'
import 'leaflet-gpx'
import styles from './TrackVisualizer.module.css'

const TrackVisualizer = ({
	gpxUrl,
	onTrackLoaded,
	startMarker,
	endMarker,
	onMapReady,
	trimmedSegment,
}) => {
	const mapContainerRef = useRef(null)
	const mapInstanceRef = useRef(null)
	const gpxLayerRef = useRef(null)
	const [loading, setLoading] = useState(true)
	const [trackStats, setTrackStats] = useState(null)
	const [mapReady, setMapReady] = useState(false)
	const [allTrackPoints, setAllTrackPoints] = useState([])
	const [markers, setMarkers] = useState({ start: null, end: null })

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã
	useEffect(() => {
		if (!mapContainerRef.current || mapInstanceRef.current) return

		console.log('üó∫Ô∏è –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –∫–∞—Ä—Ç—É...')

		const mapInstance = L.map(mapContainerRef.current).setView(
			[52.416925, 103.738906],
			15
		)

		L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
			attribution: '¬© OpenStreetMap',
			maxZoom: 19,
		}).addTo(mapInstance)

		mapInstanceRef.current = mapInstance

		setTimeout(() => {
			setMapReady(true)
			console.log('‚úÖ –ö–∞—Ä—Ç–∞ –≥–æ—Ç–æ–≤–∞')
			if (onMapReady) {
				onMapReady(mapInstance)
			}
		}, 300)

		return () => {
			console.log('üóëÔ∏è –£–¥–∞–ª—è—é –∫–∞—Ä—Ç—É')
			if (mapInstanceRef.current) {
				mapInstanceRef.current.remove()
				mapInstanceRef.current = null
				setMapReady(false)
			}
		}
	}, [])

	// –ó–∞–≥—Ä—É–∑–∫–∞ GPX
	useEffect(() => {
		if (!mapReady || !mapInstanceRef.current || !gpxUrl) {
			console.log('‚è≥ –û–∂–∏–¥–∞—é:', { mapReady, gpxUrl: !!gpxUrl })
			return
		}

		console.log('üöÄ –ó–∞–≥—Ä—É–∂–∞—é GPX')

		const loadGpx = async () => {
			try {
				setLoading(true)

				// –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ —Å–ª–æ—è
				if (gpxLayerRef.current) {
					mapInstanceRef.current.removeLayer(gpxLayerRef.current)
				}

				// –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –ø–∞—Ä—Å–∏–Ω–≥ GPX —Ñ–∞–π–ª–∞
				let parsedData = { points: [], totalTime: null, totalDistance: null }
				try {
					const response = await fetch(gpxUrl)
					const gpxText = await response.text()

					// –ü–∞—Ä—Å–∏–º GPX —Å —É—á–µ—Ç–æ–º namespace
					parsedData = parseGPXFile(gpxText)
					console.log(`üìä –ò–∑–≤–ª–µ—á–µ–Ω–æ ${parsedData.points.length} —Ç–æ—á–µ–∫ –∏–∑ GPX`)
					console.log(
						'‚è±Ô∏è –û–±—â–µ–µ –≤—Ä–µ–º—è –∏–∑ extensions:',
						parsedData.totalTime,
						'—Å–µ–∫—É–Ω–¥'
					)
					console.log('üìè –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è:', parsedData.totalDistance, '–º–µ—Ç—Ä–æ–≤')
				} catch (fetchError) {
					console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ GPX —Ñ–∞–π–ª–∞:', fetchError)
				}

				const points = parsedData.points

				// –°–û–ó–î–ê–ï–ú GPX –°–õ–û–ô –ü–ï–†–ï–î –¢–ï–ú –ö–ê–ö –í–ï–®–ê–¢–¨ –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò
				gpxLayerRef.current = new L.GPX(gpxUrl, {
					async: true,
					polyline_options: {
						color: '#1890ff',
						weight: 4,
						opacity: 0.8,
						lineCap: 'round',
					},
					marker_options: null,
				})

				// –¢–ï–ü–ï–†–¨ –í–ï–®–ê–ï–ú –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò
				gpxLayerRef.current.on('loaded', e => {
					console.log('‚úÖ GPX –æ—Ç–æ–±—Ä–∞–∂–µ–Ω –Ω–∞ –∫–∞—Ä—Ç–µ')
					const track = e.target

					// –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—á–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞, –ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –∏–∑ –ø–æ–ª–∏–ª–∏–Ω–∏–∏
					let finalPoints = points
					if (points.length === 0) {
						console.log('üîç –ü—Ä–æ–±—É—é –∏–∑–≤–ª–µ—á—å —Ç–æ—á–∫–∏ –∏–∑ –ø–æ–ª–∏–ª–∏–Ω–∏–∏...')
						finalPoints = extractPointsFromPolyline(track)
					}

					console.log(`üéØ –ò—Ç–æ–≥–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫: ${finalPoints.length}`)

					setAllTrackPoints(finalPoints)

					const stats = {
						distance: track.get_distance ? track.get_distance() : 0,
						name: track.get_name ? track.get_name() : '–¢—Ä–µ–∫',
						pointsCount: finalPoints.length,
						duration: track.get_total_time ? track.get_total_time() : 0,
						elevationGain: track.get_elevation_gain
							? track.get_elevation_gain()
							: 0,
					}

					setTrackStats(stats)
					setLoading(false)

					// –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É
					if (track.getBounds) {
						mapInstanceRef.current.fitBounds(track.getBounds().pad(0.1))
					}

					// –ü–µ—Ä–µ–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä
					if (onTrackLoaded) {
						console.log(
							'üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –¥–∞–Ω–Ω—ã–µ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä, —Ç–æ—á–µ–∫:',
							finalPoints.length
						)
						onTrackLoaded(track, stats, finalPoints, {
							totalTime: parsedData.totalTime,
							totalDistance: parsedData.totalDistance,
						})
					}
				})

				gpxLayerRef.current.on('error', err => {
					console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è GPX:', err)
					setLoading(false)
				})

				// –î–û–ë–ê–í–õ–Ø–ï–ú –ù–ê –ö–ê–†–¢–£ –ü–û–°–õ–ï –°–û–ó–î–ê–ù–ò–Ø
				gpxLayerRef.current.addTo(mapInstanceRef.current)
			} catch (error) {
				console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è GPX —Å–ª–æ—è:', error)
				setLoading(false)
			}
		}
		loadGpx()

		return () => {
			if (gpxLayerRef.current && mapInstanceRef.current) {
				mapInstanceRef.current.removeLayer(gpxLayerRef.current)
				gpxLayerRef.current = null
			}
		}
	}, [gpxUrl, mapReady, onTrackLoaded])

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∞—Ä–∫–µ—Ä–æ–≤ –æ–±—Ä–µ–∑–∫–∏
	useEffect(() => {
		if (
			!mapReady ||
			!mapInstanceRef.current ||
			startMarker === undefined ||
			endMarker === undefined ||
			allTrackPoints.length === 0
		) {
			return
		}

		console.log('üìç –û–±–Ω–æ–≤–ª—è—é –º–∞—Ä–∫–µ—Ä—ã –æ–±—Ä–µ–∑–∫–∏:', { startMarker, endMarker })

		// –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–µ –º–∞—Ä–∫–µ—Ä—ã
		if (markers.start) {
			mapInstanceRef.current.removeLayer(markers.start)
		}
		if (markers.end) {
			mapInstanceRef.current.removeLayer(markers.end)
		}

		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ —Ç–æ—á–µ–∫ —Ç—Ä–µ–∫–∞
		const startPoint =
			allTrackPoints[Math.min(startMarker, allTrackPoints.length - 1)]
		const endPoint =
			allTrackPoints[Math.min(endMarker, allTrackPoints.length - 1)]

		// –°–æ–∑–¥–∞–µ–º –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã
		const startIcon = L.divIcon({
			className: styles.minimalMarker,
			html: `
		<div style="
			position: relative;
		">
			<!-- –ö—Ä—É–≥ –°–í–ï–†–•–£ -->
			<div style="
				position: absolute;
				top: -15px;                    /* –ö—Ä—É–≥ –í–´–®–ï —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ */
				left: -4px;
				width: 8px;
				height: 8px;
				background: #52c41a;
				border-radius: 50%;
				border: 2px solid white;
				box-shadow: 0 0 3px rgba(0,0,0,0.5);
				z-index: 10;
			"></div>
			<!-- –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –í–ù–ò–ó–£, –æ—Å—Ç—Ä–∏–µ –Ω–∞ —Ç—Ä–µ–∫–µ -->
			<div style="
				width: 0;
				height: 0;
				border-left: 8px solid transparent;
				border-right: 8px solid transparent;
				border-top: 14px solid #52c41a;  /* –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Å–º–æ—Ç—Ä–∏—Ç –í–ù–ò–ó */
				position: absolute;
				top: -8px;                      /* –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ–¥ –∫—Ä—É–≥–æ–º */
				left: -8px;
			"></div>
		</div>
	`,
			iconSize: [16, 22] /* –í—ã—Å–æ—Ç–∞ —É—á–∏—Ç—ã–≤–∞–µ—Ç –∫—Ä—É–≥ —Å–≤–µ—Ä—Ö—É */,
			iconAnchor: [0, 0] /* –Ø–∫–æ—Ä—å –≤ –í–ï–†–•–ù–ï–ô —Ç–æ—á–∫–µ (–≥–¥–µ –∫—Ä—É–≥) */,
		})

		const endIcon = L.divIcon({
			className: styles.minimalMarker,
			html: `
		<div style="
			position: relative;
		">
			<!-- –ö—Ä—É–≥ –°–í–ï–†–•–£ -->
			<div style="
				position: absolute;
				top: -15px;                    /* –ö—Ä—É–≥ –í–´–®–ï —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ */
				left: -4px;
				width: 8px;
				height: 8px;
				background: #f5222d;
				border-radius: 50%;
				border: 2px solid white;
				box-shadow: 0 0 3px rgba(0,0,0,0.5);
				z-index: 10;
			"></div>
			<!-- –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –í–ù–ò–ó–£, –æ—Å—Ç—Ä–∏–µ –Ω–∞ —Ç—Ä–µ–∫–µ -->
			<div style="
				width: 0;
				height: 0;
				border-left: 8px solid transparent;
				border-right: 8px solid transparent;
				border-top: 14px solid #f5222d;  /* –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Å–º–æ—Ç—Ä–∏—Ç –í–ù–ò–ó */
				position: absolute;
				top: -8px;                      /* –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ–¥ –∫—Ä—É–≥–æ–º */
				left: -8px;
			"></div>
		</div>
	`,
			iconSize: [16, 22],
			iconAnchor: [-2, 0] /* –Ø–∫–æ—Ä—å –≤ –í–ï–†–•–ù–ï–ô —Ç–æ—á–∫–µ (–≥–¥–µ –∫—Ä—É–≥) */,
		})
		const newMarkers = {}

		if (startPoint) {
			newMarkers.start = L.marker([startPoint.lat, startPoint.lng], {
				icon: startIcon,
			})
				.addTo(mapInstanceRef.current)
				.bindPopup(
					`<div style="font-size: 12px;">–ù–∞—á–∞–ª–æ<br>–¢–æ—á–∫–∞ ${startMarker + 1}/${
						allTrackPoints.length
					}</div>`
				)
		}

		if (endPoint) {
			newMarkers.end = L.marker([endPoint.lat, endPoint.lng], { icon: endIcon })
				.addTo(mapInstanceRef.current)
				.bindPopup(
					`<div style="font-size: 12px;">–ö–æ–Ω–µ—Ü<br>–¢–æ—á–∫–∞ ${endMarker + 1}/${
						allTrackPoints.length
					}</div>`
				)
		}

		setMarkers(newMarkers)

		// –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
		return () => {
			if (markers.start && mapInstanceRef.current) {
				mapInstanceRef.current.removeLayer(markers.start)
			}
			if (markers.end && mapInstanceRef.current) {
				mapInstanceRef.current.removeLayer(markers.end)
			}
		}
	}, [startMarker, endMarker, mapReady, allTrackPoints])
	useEffect(() => {
		if (
			!mapReady ||
			!mapInstanceRef.current ||
			!trimmedSegment ||
			!allTrackPoints.length
		) {
			return
		}

		const { start, end } = trimmedSegment

		// –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫
		if (window.trimmedSegmentLayer) {
			mapInstanceRef.current.removeLayer(window.trimmedSegmentLayer)
		}

		// –°–æ–∑–¥–∞–µ–º —Ç–æ—á–∫–∏ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞
		const segmentPoints = allTrackPoints
			.slice(start, end + 1)
			.map(point => [point.lat, point.lng])

		if (segmentPoints.length > 1) {
			// –°–æ–∑–¥–∞–µ–º —à—Ç—Ä–∏—Ö–ø—É–Ω–∫—Ç–∏—Ä–Ω—É—é –ª–∏–Ω–∏—é
			window.trimmedSegmentLayer = L.polyline(segmentPoints, {
				color: '#ff4d4f',
				weight: 4,
				opacity: 0.8,
				dashArray: '10, 10', // ‚Üê –®–¢–†–ò–•–ü–£–ù–ö–¢–ò–†
				lineCap: 'round',
				className: styles.trimmedSegment,
			}).addTo(mapInstanceRef.current)
		}

		return () => {
			if (window.trimmedSegmentLayer && mapInstanceRef.current) {
				mapInstanceRef.current.removeLayer(window.trimmedSegmentLayer)
			}
		}
	}, [trimmedSegment, mapReady, allTrackPoints])
	// –§—É–Ω–∫—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ GPX —Ñ–∞–π–ª–∞
	const parseGPXFile = gpxText => {
		const points = []
		try {
			const parser = new DOMParser()
			const xmlDoc = parser.parseFromString(gpxText, 'text/xml')

			// GPX namespace
			const gpxNs = 'http://www.topografix.com/GPX/1/0'

			// –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Å —É—á–µ—Ç–æ–º namespace
			const trkpts = xmlDoc.getElementsByTagNameNS(gpxNs, 'trkpt')
			console.log(`–ù–∞–π–¥–µ–Ω–æ trkpt —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (—Å namespace): ${trkpts.length}`)

			// –ü–∞—Ä—Å–∏–º –≤—Ä–µ–º—è –∏–∑ metadata –∏–ª–∏ extensions
			let totalTime = null
			let totalDistance = null

			// –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ extensions
			const extensions = xmlDoc.getElementsByTagNameNS(gpxNs, 'extensions')[0]
			if (extensions) {
				const timeElem = extensions.getElementsByTagName('totalTime')[0]
				const distElem = extensions.getElementsByTagName('totalDistance')[0]

				if (timeElem) totalTime = parseFloat(timeElem.textContent)
				if (distElem) totalDistance = parseFloat(distElem.textContent)

				console.log('üìä –î–∞–Ω–Ω—ã–µ –∏–∑ extensions:', {
					totalTime,
					totalDistance,
					timeElemText: timeElem?.textContent,
					distElemText: distElem?.textContent,
				})
			}

			// –ü–∞—Ä—Å–∏–º —Ç–æ—á–∫–∏
			for (let i = 0; i < trkpts.length; i++) {
				const trkpt = trkpts[i]
				const lat = parseFloat(trkpt.getAttribute('lat'))
				const lon = parseFloat(trkpt.getAttribute('lon'))

				if (!isNaN(lat) && !isNaN(lon)) {
					// –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è —Å —É—á–µ—Ç–æ–º namespace
					const timeElem = trkpt.getElementsByTagNameNS(gpxNs, 'time')[0]
					const timeText = timeElem?.textContent

					// –ü–∞—Ä—Å–∏–º –≤—Ä–µ–º—è
					let timestamp = null
					if (timeText) {
						try {
							const date = new Date(timeText)
							if (!isNaN(date.getTime())) {
								timestamp = date.getTime()
							}
						} catch (error) {
							console.warn('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤—Ä–µ–º–µ–Ω–∏:', error)
						}
					}

					const eleElem = trkpt.getElementsByTagNameNS(gpxNs, 'ele')[0]

					points.push({
						lat: lat,
						lng: lon,
						index: i,
						time: timeText,
						timestamp: timestamp,
						elevation: eleElem ? parseFloat(eleElem.textContent) : null,
						type: 'track',
					})
				}
			}

			// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ totalTime –∏ totalDistance
			return {
				points,
				totalTime, // 3418 —Å–µ–∫—É–Ω–¥
				totalDistance, // 5720 –º–µ—Ç—Ä–æ–≤
			}
		} catch (error) {
			console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ GPX:', error)
			return { points: [], totalTime: null, totalDistance: null }
		}
	}

	// –§—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–æ—á–µ–∫ –∏–∑ –ø–æ–ª–∏–ª–∏–Ω–∏–∏ Leaflet
	const extractPointsFromPolyline = track => {
		const points = []

		if (!track._layers) {
			console.log('–ù–µ—Ç —Å–ª–æ–µ–≤ –≤ track._layers')
			return points
		}

		Object.values(track._layers).forEach(layer => {
			if (layer instanceof L.Polyline) {
				try {
					const latLngs = layer.getLatLngs()

					if (Array.isArray(latLngs)) {
						if (latLngs.length > 0 && latLngs[0].lat !== undefined) {
							latLngs.forEach((ll, index) => {
								points.push({
									lat: ll.lat,
									lng: ll.lng,
									index: points.length,
									source: 'polyline-flat',
								})
							})
						} else if (Array.isArray(latLngs[0])) {
							latLngs.forEach((segment, segmentIndex) => {
								if (Array.isArray(segment)) {
									segment.forEach((ll, pointIndex) => {
										if (ll && ll.lat !== undefined) {
											points.push({
												lat: ll.lat,
												lng: ll.lng,
												index: points.length,
												segment: segmentIndex,
												source: 'polyline-nested',
											})
										}
									})
								}
							})
						}
					}
				} catch (error) {
					console.warn('–û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–æ—á–µ–∫ –∏–∑ –ø–æ–ª–∏–ª–∏–Ω–∏–∏:', error)
				}
			}
		})

		console.log(`–ò–∑–≤–ª–µ—á–µ–Ω–æ ${points.length} —Ç–æ—á–µ–∫ –∏–∑ –ø–æ–ª–∏–ª–∏–Ω–∏–∏`)
		return points
	}

	return (
		<div className={styles.container}>
			<div
				ref={mapContainerRef}
				className={styles.mapContainer}
				style={{
					width: '100%',
					height: '400px',
					minHeight: '400px',
					borderRadius: '8px',
					overflow: 'hidden',
					border: '1px solid #f0f0f0',
					position: 'relative',
				}}
			/>

			{loading && (
				<div className={styles.loadingOverlay}>
					<div className={styles.spinner} />
					<div>–ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞...</div>
				</div>
			)}

			{!mapReady && !loading && (
				<div className={styles.loadingOverlay}>
					<div>–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã...</div>
				</div>
			)}
		</div>
	)
}

export default TrackVisualizer



===== src/features/gpx-tools/ui/components/UnifiedMap.jsx =====
import React, { useEffect, useRef, useState, useCallback } from 'react'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'
import 'leaflet-gpx'
import styles from './UnifiedMap.module.css'

const UnifiedMap = ({
	// –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
	center = [52.416925, 103.738906],
	zoom = 15,

	// –¢—Ä–µ–∫–∏ (GPX)
	trackUrls = [], // –º–∞—Å—Å–∏–≤ URL —Ç—Ä–µ–∫–æ–≤
	trackColors = ['#1890ff', '#f5222d', '#52c41a', '#faad14'], // —Ü–≤–µ—Ç–∞ —Ç—Ä–µ–∫–æ–≤
	trackNames = [], // –∏–º–µ–Ω–∞ —Ç—Ä–µ–∫–æ–≤ –¥–ª—è –ª–µ–≥–µ–Ω–¥—ã

	// –ü–æ–ª–∏–ª–∏–Ω–∏–∏ (–ø—Ä—è–º—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
	polylines = [], // –º–∞—Å—Å–∏–≤ –º–∞—Å—Å–∏–≤–æ–≤ —Ç–æ—á–µ–∫ [{lat, lng}]
	polylineColors = ['#ff4d4f', '#fa8c16', '#13c2c2'],
	polylineOptions = [], // –æ–ø—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–ª–∏–ª–∏–Ω–∏–∏

	// –ú–∞—Ä–∫–µ—Ä—ã
	markers = [], // –º–∞—Å—Å–∏–≤ {lat, lng, icon?, popup?}

	// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
	onMapReady, // callback —Å –∏–Ω—Å—Ç–∞–Ω—Å–æ–º –∫–∞—Ä—Ç—ã
	onTracksLoaded, // callback –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤—Å–µ—Ö —Ç—Ä–µ–∫–æ–≤ (–º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫)
	fitBounds = true, // –∞–≤—Ç–æ—Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
	className = '',
	loading = false,

	// –î–ª—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ —Ç—Ä–µ–∫–æ–≤
	trimStart = null,
	trimEnd = null,
	trimmedSegment = null,

	// –î–ª—è –ø–ª–µ–µ—Ä–∞/—Å—Ä–∞–≤–Ω–µ–Ω–∏—è
	currentPointIndex = null,
	playerMarkerOptions = null,
	showLegend = false,

	// –í—ã—Å–æ—Ç–∞ –∫–∞—Ä—Ç—ã
	height = '400px',
}) => {
	const mapContainerRef = useRef(null)
	const mapInstanceRef = useRef(null)

	// –°—Å—ã–ª–∫–∏ –Ω–∞ —Å–ª–æ–∏ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
	const trackLayersRef = useRef([])
	const polylineLayersRef = useRef([])
	const markerLayersRef = useRef([])
	const trimmedSegmentLayerRef = useRef(null)
	const playerMarkerRef = useRef(null)

	const [mapReady, setMapReady] = useState(false)
	const [loadedTracks, setLoadedTracks] = useState([]) // –º–∞—Å—Å–∏–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤ —Å —Ç–æ—á–∫–∞–º–∏

	// 1. –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–†–¢–´ (–æ—Å–Ω–æ–≤–Ω–æ–π useEffect)
	useEffect(() => {
		if (!mapContainerRef.current || mapInstanceRef.current) return

		console.log('üó∫Ô∏è UnifiedMap: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –∫–∞—Ä—Ç—É...')

		const mapInstance = L.map(mapContainerRef.current).setView(center, zoom)

		L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
			attribution: '¬© OpenStreetMap',
			maxZoom: 19,
		}).addTo(mapInstance)

		mapInstanceRef.current = mapInstance

		setMapReady(true)
		console.log('‚úÖ UnifiedMap: –ö–∞—Ä—Ç–∞ –≥–æ—Ç–æ–≤–∞')

		if (onMapReady) {
			onMapReady(mapInstance)
		}

		return () => {
			console.log('üóëÔ∏è UnifiedMap: –£–¥–∞–ª—è—é –∫–∞—Ä—Ç—É')
			if (mapInstanceRef.current) {
				mapInstanceRef.current.remove()
				mapInstanceRef.current = null
				setMapReady(false)
			}
		}
	}, []) // –¢–æ–ª—å–∫–æ –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏

	// 2. –ó–ê–ì–†–£–ó–ö–ê –¢–†–ï–ö–û–í (GPX)
	useEffect(() => {
		if (!mapReady || !mapInstanceRef.current || trackUrls.length === 0) return

		console.log(`üîÑ UnifiedMap: –ó–∞–≥—Ä—É–∂–∞—é ${trackUrls.length} —Ç—Ä–µ–∫–æ–≤...`)

		// –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Ç—Ä–µ–∫–∏
		trackLayersRef.current.forEach(layer => {
			if (layer && mapInstanceRef.current.hasLayer(layer)) {
				mapInstanceRef.current.removeLayer(layer)
			}
		})
		trackLayersRef.current = []
		setLoadedTracks([])

		const allTrackPoints = []
		let tracksLoadedCount = 0

		// –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞–∂–¥—ã–π —Ç—Ä–µ–∫
		trackUrls.forEach((url, index) => {
			const color = trackColors[index % trackColors.length]

			try {
				const gpxLayer = new L.GPX(url, {
					async: true,
					polyline_options: {
						color: color,
						weight: 3,
						opacity: 0.8,
						lineCap: 'round',
					},
					marker_options: null, // –±–µ–∑ –º–∞—Ä–∫–µ—Ä–æ–≤
				})

				gpxLayer.on('loaded', e => {
					const track = e.target
					console.log(`‚úÖ UnifiedMap: –¢—Ä–µ–∫ ${index + 1} –∑–∞–≥—Ä—É–∂–µ–Ω`)

					// –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ—á–∫–∏ –∏–∑ —Ç—Ä–µ–∫–∞
					const points = extractPointsFromGPX(track)
					allTrackPoints[index] = {
						points,
						color,
						name: trackNames[index] || `–¢—Ä–µ–∫ ${index + 1}`,
					}

					tracksLoadedCount++

					// –ö–æ–≥–¥–∞ –≤—Å–µ —Ç—Ä–µ–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
					if (tracksLoadedCount === trackUrls.length) {
						setLoadedTracks(allTrackPoints)

						if (onTracksLoaded) {
							onTracksLoaded(allTrackPoints.map(t => t.points))
						}

						// –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
						if (fitBounds && allTrackPoints.length > 0) {
							setTimeout(() => {
								const bounds = getAllBounds(allTrackPoints)
								if (bounds) {
									mapInstanceRef.current.fitBounds(bounds.pad(0.1))
								}
							}, 500)
						}
					}
				})

				gpxLayer.on('error', e => {
					console.error(
						`‚ùå UnifiedMap: –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç—Ä–µ–∫–∞ ${index + 1}:`,
						e.error
					)
				})

				gpxLayer.addTo(mapInstanceRef.current)
				trackLayersRef.current[index] = gpxLayer
			} catch (error) {
				console.error(
					`‚ùå UnifiedMap: –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è GPX —Å–ª–æ—è ${index + 1}:`,
					error
				)
			}
		})

		return () => {
			// –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
			trackLayersRef.current.forEach(layer => {
				if (layer && mapInstanceRef.current?.hasLayer(layer)) {
					mapInstanceRef.current.removeLayer(layer)
				}
			})
		}
	}, [trackUrls, mapReady, fitBounds])

	// 3. –û–¢–†–ò–°–û–í–ö–ê –ü–û–õ–ò–õ–ò–ù–ò–ô
	useEffect(() => {
		if (!mapReady || !mapInstanceRef.current || polylines.length === 0) return

		// –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–ª–∏–ª–∏–Ω–∏–∏
		polylineLayersRef.current.forEach(layer => {
			if (layer && mapInstanceRef.current.hasLayer(layer)) {
				mapInstanceRef.current.removeLayer(layer)
			}
		})
		polylineLayersRef.current = []

		// –†–∏—Å—É–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª–∏–ª–∏–Ω–∏–∏
		polylines.forEach((points, index) => {
			if (!points || points.length < 2) return

			const color = polylineColors[index % polylineColors.length]
			const options = {
				color,
				weight: 3,
				opacity: 0.7,
				...polylineOptions[index],
			}

			const latlngs = points.map(p => [p.lat, p.lng])
			const polyline = L.polyline(latlngs, options).addTo(
				mapInstanceRef.current
			)

			polylineLayersRef.current[index] = polyline
		})
	}, [polylines, mapReady])

	// 4. –û–¢–†–ò–°–û–í–ö–ê –ú–ê–†–ö–ï–†–û–í
	useEffect(() => {
		if (!mapReady || !mapInstanceRef.current || markers.length === 0) return

		// –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –º–∞—Ä–∫–µ—Ä—ã
		markerLayersRef.current.forEach(layer => {
			if (layer && mapInstanceRef.current.hasLayer(layer)) {
				mapInstanceRef.current.removeLayer(layer)
			}
		})
		markerLayersRef.current = []

		// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –º–∞—Ä–∫–µ—Ä—ã
		markers.forEach((marker, index) => {
			if (!marker || !marker.lat || !marker.lng) return

			let icon = marker.icon
			if (!icon) {
				// –î–µ—Ñ–æ–ª—Ç–Ω–∞—è –∏–∫–æ–Ω–∫–∞
				icon = L.divIcon({
					html: `<div style="
            width: 12px;
            height: 12px;
            background: #ff4d4f;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
          "></div>`,
					iconSize: [16, 16],
					iconAnchor: [8, 8],
				})
			}

			const leafletMarker = L.marker([marker.lat, marker.lng], { icon }).addTo(
				mapInstanceRef.current
			)

			if (marker.popup) {
				leafletMarker.bindPopup(marker.popup)
			}

			markerLayersRef.current[index] = leafletMarker
		})
	}, [markers, mapReady])

	// 5. –í–´–î–ï–õ–ï–ù–ù–´–ô –°–ï–ì–ú–ï–ù–¢ (–¥–ª—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞)
	useEffect(() => {
		if (
			!mapReady ||
			!mapInstanceRef.current ||
			!trimmedSegment ||
			!loadedTracks[0]
		)
			return

		const { start, end } = trimmedSegment
		const trackPoints = loadedTracks[0].points

		if (start >= end || start < 0 || end >= trackPoints.length) return

		// –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫
		if (trimmedSegmentLayerRef.current) {
			mapInstanceRef.current.removeLayer(trimmedSegmentLayerRef.current)
		}

		// –°–æ–∑–¥–∞–µ–º —Ç–æ—á–∫–∏ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞
		const segmentPoints = trackPoints
			.slice(start, end + 1)
			.map(point => [point.lat, point.lng])

		if (segmentPoints.length > 1) {
			trimmedSegmentLayerRef.current = L.polyline(segmentPoints, {
				color: '#ff4d4f',
				weight: 4,
				opacity: 0.8,
				dashArray: '10, 10', // —à—Ç—Ä–∏—Ö–ø—É–Ω–∫—Ç–∏—Ä
				lineCap: 'round',
			}).addTo(mapInstanceRef.current)
		}

		return () => {
			if (trimmedSegmentLayerRef.current) {
				mapInstanceRef.current.removeLayer(trimmedSegmentLayerRef.current)
			}
		}
	}, [trimmedSegment, mapReady, loadedTracks])

	// 6. –ú–ê–†–ö–ï–† –ü–õ–ï–ï–†–ê (–¥–≤–∏–∂—É—â–∞—è—Å—è —Ç–æ—á–∫–∞)
	useEffect(() => {
		if (
			!mapReady ||
			!mapInstanceRef.current ||
			currentPointIndex == null ||
			!loadedTracks[0]
		)
			return

		const trackPoints = loadedTracks[0].points
		if (currentPointIndex < 0 || currentPointIndex >= trackPoints.length) return

		// –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –º–∞—Ä–∫–µ—Ä
		if (playerMarkerRef.current) {
			mapInstanceRef.current.removeLayer(playerMarkerRef.current)
		}

		const point = trackPoints[currentPointIndex]
		const iconOptions = playerMarkerOptions || {
			html: `<div style="
        width: 16px;
        height: 16px;
        background: #52c41a;
        border-radius: 50%;
        border: 3px solid white;
        box-shadow: 0 0 8px rgba(0,0,0,0.5);
      "></div>`,
			iconSize: [22, 22],
			iconAnchor: [11, 11],
		}

		const icon = L.divIcon(iconOptions)
		playerMarkerRef.current = L.marker([point.lat, point.lng], { icon })
			.addTo(mapInstanceRef.current)
			.bindPopup(`–¢–æ—á–∫–∞ ${currentPointIndex + 1}`)

		return () => {
			if (playerMarkerRef.current) {
				mapInstanceRef.current.removeLayer(playerMarkerRef.current)
			}
		}
	}, [currentPointIndex, mapReady, loadedTracks, playerMarkerOptions])

	// –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò

	const extractPointsFromGPX = useCallback(track => {
		const points = []
		track.getLayers().forEach(layer => {
			if (layer instanceof L.Polyline) {
				const latlngs = layer.getLatLngs()
				latlngs.forEach((latlng, index) => {
					points.push({
						lat: latlng.lat,
						lng: latlng.lng,
						elevation: latlng.meta?.ele,
						time: latlng.meta?.time,
						timestamp: latlng.meta?.time
							? new Date(latlng.meta.time).getTime()
							: null,
					})
				})
			}
		})
		return points
	}, [])

	const getAllBounds = useCallback(tracks => {
		if (!tracks || tracks.length === 0) return null

		let bounds = null
		tracks.forEach(track => {
			if (track.points && track.points.length > 0) {
				const trackBounds = L.latLngBounds(
					track.points.map(p => [p.lat, p.lng])
				)
				if (!bounds) {
					bounds = trackBounds
				} else {
					bounds.extend(trackBounds)
				}
			}
		})
		return bounds
	}, [])

	// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞—Ä—Ç—ã
	const fitMapToTracks = useCallback(() => {
		if (!mapReady || !mapInstanceRef.current || loadedTracks.length === 0)
			return

		const bounds = getAllBounds(loadedTracks)
		if (bounds) {
			mapInstanceRef.current.fitBounds(bounds.pad(0.1))
		}
	}, [mapReady, loadedTracks, getAllBounds])

	// –†–ï–ù–î–ï–†
	return (
		<div className={`${styles.container} ${className}`}>
			<div
				ref={mapContainerRef}
				className={styles.mapContainer}
				style={{
					width: '100%',
					height: height,
					borderRadius: '8px',
					overflow: 'hidden',
					border: '1px solid #f0f0f0',
					position: 'relative',
				}}
			/>

			{/* –õ–µ–≥–µ–Ω–¥–∞ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ) */}
			{showLegend && loadedTracks.length > 0 && (
				<div className={styles.legend}>
					{loadedTracks.map((track, index) => (
						<div key={index} className={styles.legendItem}>
							<div
								className={styles.colorBox}
								style={{ backgroundColor: track.color || trackColors[index] }}
							/>
							<span>{track.name || `–¢—Ä–µ–∫ ${index + 1}`}</span>
						</div>
					))}
				</div>
			)}

			{/* –ó–∞–≥—Ä—É–∑–∫–∞ */}
			{loading && (
				<div className={styles.loadingOverlay}>
					<div className={styles.spinner} />
					<div>–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç—ã...</div>
				</div>
			)}
		</div>
	)
}

export default UnifiedMap



